<!DOCTYPE html>
<html manifest="matreshka.appcache">
	<head>
		<title>Matreshka.js по-русски</title>
		<link rel="stylesheet" href="css/screen.css">
		<meta name="viewport" content="initial-scale=1, width=device-width">
		<meta charset="UTF-8">
		<link rel="apple-touch-icon" sizes="57x57" href="icons/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="icons/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="icons/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="icons/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="icons/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="icons/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="icons/apple-touch-icon-152x152.png">
		<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180x180.png">
		<link rel="icon" type="image/png" href="icons/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="icons/favicon-194x194.png" sizes="194x194">
		<link rel="icon" type="image/png" href="icons/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="icons/android-chrome-192x192.png" sizes="192x192">
		<link rel="icon" type="image/png" href="icons/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="icons/android-chrome-manifest.json">
		<link rel="shortcut icon" href="icons/favicon.ico">
		<meta name="apple-mobile-web-app-title" content="Matreshka.js по-русски">
		<meta name="application-name" content="Matreshka.js по-русски">
		<meta name="msapplication-TileColor" content="#00aba9">
		<meta name="msapplication-TileImage" content="icons/mstile-144x144.png">
		<meta name="msapplication-config" content="icons/browserconfig.xml">
		<meta name="theme-color" content="#66bb6a">
		<style>
			.loader {
				position: fixed;
				width: 100%;
				height: 100%;
				background: white no-repeat center center;
				background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMSBUaW55Ly9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLXRpbnkuZHRkIj48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjM3cHgiIGhlaWdodD0iMzc3cHgiPjxkZWZzPjxzdHlsZT5wYXRoIHstd2Via2l0LWFuaW1hdGlvbjogY29sb3IgNnMgZWFzZS1pbi1vdXQgaW5maW5pdGU7YW5pbWF0aW9uOiBjb2xvciA2cyBlYXNlLWluLW91dCBpbmZpbml0ZTtzdHJva2UtbGluZWNhcDogcm91bmQ7fXBhdGg6bGFzdC1jaGlsZCB7YW5pbWF0aW9uLWRlbGF5OiAzczstd2Via2l0LWFuaW1hdGlvbi1kZWxheTogM3M7fUAtd2Via2l0LWtleWZyYW1lcyBjb2xvciB7MTAwJSwgMCUge3N0cm9rZTogI2VmNTM1MDt9NDAlIHtzdHJva2U6ICMwMDU3ZTc7fTY2JSB7c3Ryb2tlOiAjMDA4NzQ0O304MCUsIDkwJSB7c3Ryb2tlOiAjZmZhNzAwO319QGtleWZyYW1lcyBjb2xvciB7MTAwJSwgMCUge3N0cm9rZTogI2VmNTM1MDt9NDAlIHtzdHJva2U6ICMwMDU3ZTc7fTY2JSB7c3Ryb2tlOiAjMDA4NzQ0O304MCUsIDkwJSB7c3Ryb2tlOiAjZmZhNzAwO319PC9zdHlsZT48L2RlZnM+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQ2OSwgLTEyOSkiPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzY2YmI2YSAiIHN0cm9rZS13aWR0aD0iMTYiIGQ9Ik01ODcuMjkyLDQ5Ni40MjUgICAgYzM4LjU3OSwwLDY5LjkxLTcuMzkyLDc4LjQ2Ni0yMC4zOTRjMTIuNzY0LTM2LjIxMSwzMi4yLTgzLjMzNiwzMC4zODMtMTI0LjY1NWMtMi4xNDgtNDguODU3LTMzLjUyNC03Mi4yODUtMzQuMzI4LTExMS4wOTcgICAgYy0xLjQ3OS03MS4zODQtMjIuOTE3LTEwMi4zMTMtNzQuNTIxLTEwMi4zMTNjLTUxLjYwMiwwLTczLjA0MSwzMC45MjktNzQuNTIsMTAyLjMxM2MtMC44MDQsMzguODEyLTMyLjE4LDYyLjI0MS0zNC4zMjgsMTExLjA5NyAgICBjLTEuODE3LDQxLjMxOSwxNy42MTksODguNDQ0LDMwLjM4MywxMjQuNjU1QzUxNy4zODMsNDg5LjAzMyw1NDguNzE0LDQ5Ni40MjUsNTg3LjI5Miw0OTYuNDI1eiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2VmNTM1MCIgc3Ryb2tlLXdpZHRoPSIxNiIgZD0iTTU4Ny4yOTIsNDY0LjkyNiAgICBjMjMuMDQ2LDAsNDEuNzYyLTQuNDE1LDQ2Ljg3Mi0xMi4xODNjNy42MjQtMjEuNjMsMTkuMjM1LTQ5Ljc4LDE4LjE0OS03NC40NjNjLTEuMjgzLTI5LjE4NS0yMC4wMjYtNDMuMTgtMjAuNTA2LTY2LjM2NSAgICBjLTAuODg0LTQyLjY0MS0xMy42OS02MS4xMTctNDQuNTE2LTYxLjExN3MtNDMuNjMyLDE4LjQ3Ni00NC41MTUsNjEuMTE3Yy0wLjQ4LDIzLjE4Ni0xOS4yMjMsMzcuMTgxLTIwLjUwNiw2Ni4zNjUgICAgYy0xLjA4NiwyNC42ODMsMTAuNTI0LDUyLjgzMywxOC4xNDksNzQuNDYzQzU0NS41MzEsNDYwLjUxMSw1NjQuMjQ3LDQ2NC45MjYsNTg3LjI5Miw0NjQuOTI2eiIvPjwvZz48L3N2Zz4=);

				z-index: 10;
			}
		</style>
	</head>
	<body>
		<header>
			<div class="header-content">
				<i class="show-nav"></i>
				<div class="inner"></div>
				<i class="show-search"></i>
			</div>
			<div class="search-content">
				<i class="back"></i><input type="text" class="search">
				<ul class="search-results-dropdown"></ul>
			</div>
		</header>
		<iframe id="typo-iframe" class="hide" name="typo-iframe"></iframe>
		<div class="loader"></div>
<nav>
	<span class="view-switcher">
		<span data-value="all" class="checked">Всё сразу</span><span data-value="per-one">По одному</span>
	</span>
	<a href="#home">Начало</a>
	<a href="#introduction">Введение</a>
	<a href="#getting-started">С чего начать? <span class="expand"></span><span class="hidden-active-child"></span></a>
	<div class="submenu-wrapper">
		<ul data-submenu="getting-started">
			<li><a href="#hello-world">Hello World</a>
			<li><a href="#todomvc">TodoMVC</a>
			<li><a href="#how-to-include">Как подключить</a>
		</ul>
	</div>	
	
	<a href="#Matreshka" data-name="Matreshka">
		<b>Matreshka</b>
		
		<i class="important" title="Важно"></i>
		<span class="expand"></span>
		<span class="hidden-active-child"></span>
	</a>
	<div class="submenu-wrapper">
		<ul data-submenu="Matreshka">
			
				<li>
					<a href="#Matreshka-isMK" title="isMK всегда равен true. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса Matreshka" data-name="isMK">
						isMK 
					</a>
				</li>
			
			
				<li>
					<a href="#Matreshka-on" title="Добавляет обработчик события" data-name="on">
						on
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
				<li>
					<a href="#Matreshka-onDebounce" title="Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени" data-name="onDebounce">
						onDebounce
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-once" title="Добавляет обработик событий, который может быть вызван однажды" data-name="once">
						once
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-off" title="Удаляет обработчик события" data-name="off">
						off
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-trigger" title="Генерирует событие" data-name="trigger">
						trigger
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
				<li>
					<a href="#Matreshka-bindNode" title="Связывает свойство объекта с HTML элементом" data-name="bindNode">
						bindNode
						<i class="important" title="+self.lang.important+"></i>
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-bindNode">
								
									<li>
										<a href="#Matreshka-bindNode(2)" title="Альтернативный синтаксис: пары &quot;ключ-элемент&quot;" data-name="bindNode#2">
											#2
										</a>
									</li>
								
									<li>
										<a href="#Matreshka-bindNode(3)" title="Альтернативный синтаксис &quot;куча аргументов&quot;" data-name="bindNode#3">
											#3
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-bindOptionalNode" title="Работает в точности так же, как и Matreshka#bindNode но не бросает исключение, если аргумент node - пустой массив, undefined или не существует" data-name="bindOptionalNode">
						bindOptionalNode
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-unbindNode" title="Разрывает связь между свойством и HTML элементом" data-name="unbindNode">
						unbindNode
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-unbindNode">
								
									<li>
										<a href="#Matreshka-unbindNode(2)" title="Альтернативный синтаксис Matreshka#unbindNode &quot;ключ-элемент&quot; для Matreshka#unbindNode" data-name="unbindNode#2">
											#2
										</a>
									</li>
								
									<li>
										<a href="#Matreshka-unbindNode(3)" title="Альтернативный синтаксис Matreshka#unbindNode &quot;большая куча аргументов&quot;" data-name="unbindNode#3">
											#3
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-boundAll" title="Возвращает коллекцию привязанных элементов" data-name="boundAll">
						boundAll
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-$bound" title="Делает то же самое, что и Matreshka#boundAll" data-name="$bound">
						$bound
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-bound" title="Возвращает первый привязанный элемент или null" data-name="bound">
						bound
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-selectAll" title="Возвращает элементы из песочницы, соответствующие селектору" data-name="selectAll">
						selectAll
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-$(instance)" title="Делает то же самое, что и Matreshka#selectAll" data-name="$">
						$
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-select" title="Возвращает элемент из песочницы, соответствующий селектору" data-name="select">
						select
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-eq" title="Проверяет экземпляр на равенство другому объекту" data-name="eq">
						eq
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-defineGetter" title="Устанавливает кастомный геттер для свойства" data-name="defineGetter">
						defineGetter
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-defineGetter">
								
									<li>
										<a href="#Matreshka-defineGetter(2)" title="Альтернативный синтаксис метода Matreshka#defineGetter для установки геттера &quot;ключ-геттер&quot;" data-name="defineGetter#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-defineSetter" title="Устанавливает кастомный сетер для свойства" data-name="defineSetter">
						defineSetter
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-defineSetter">
								
									<li>
										<a href="#Matreshka-defineSetter(2)" title="Альтернативный синтаксис метода Matreshka#defineSetter для установки сеттера &quot;ключ-сеттер&quot;" data-name="defineSetter#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-mediate" title="Трансформирует значение свойства при его изменении" data-name="mediate">
						mediate
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-mediate">
								
									<li>
										<a href="#Matreshka-mediate(2)" title="Альтернативный синтаксис метода Matreshka#mediate, принимающий в качестве аргумента объект &quot;ключ-медиатор&quot;" data-name="mediate#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-linkProps" title="Создает зависимость значения одного свойства от значений других" data-name="linkProps">
						linkProps
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-linkProps">
								
									<li>
										<a href="#Matreshka-linkProps(2)" title="Дополнительная возможность метода Matreshka#linkProps: зависимость от значений свойств других экземпляров" data-name="linkProps#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-get" title="Возвращает значение свойства" data-name="get">
						get
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-set" title="Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента" data-name="set">
						set
						<i class="important" title="+self.lang.important+"></i>
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-set">
								
									<li>
										<a href="#Matreshka-set(2)" title="Альтернативный синтаксис метода Matreshka#set &quot;ключ-значение&quot;" data-name="set#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-remove" title="Удаляет свойство" data-name="remove">
						remove
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka-define" title="Полностью переписывает дескриптор свойства, используя Object.defineProperty" data-name="define">
						define
						
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka-define">
								
									<li>
										<a href="#Matreshka-define(2)" title="Альтернативный синтаксис для метода Matreshka#define &quot;ключ-дескриптор&quot;" data-name="define#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka-delay" title="Выполняет функцию после заданной задержки" data-name="delay">
						delay
						
						
					</a>
					
			
			
				<li>
					<a href="#Matreshka.version" title="Версия Матрешки" data-name="version">
						version 
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.isXDR" title="Использует ли Матрешка хак с XDomainRequest. Другими словами, является ли текущий браузер Internet Explorer 8" data-name="isXDR">
						isXDR 
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.defaultBinders" title="Массив функций, возвращающих соответствующий байндер" data-name="defaultBinders">
						defaultBinders 
					</a>
				</li>
			 
			
				<li>
					<a href="#Matreshka.extend" title="Небольшая вспомогательная функция, которая расширяет один объект свойствами другого объекта" data-name="extend">
						extend  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.Class" title="Содержит ссылку на глобальную функцию Class" data-name="Class">
						Class  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.$(static)" title="Библиотека, используемая Матрешкой (jQuery, Zepto, Balalaika или др.)" data-name="$">
						$  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.$b" title="Встроенная микро-библиотека Балалайка" data-name="$b">
						$b  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.useAs$" title="Завтавляет использовать определенную библиотеку для работы с DOM" data-name="useAs$">
						useAs$  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.noop" title="Пустая функция, которая ничего не делает" data-name="noop">
						noop  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.each" title="Итерирует любой объект, прогоняя каждое его свойство через функцию callback" data-name="each">
						each  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.debounce" title="Запускает функцию лишь однажды после истечения таймера. С каждой попыткой запуска таймер обновляется" data-name="debounce">
						debounce  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.lookForBinder" title="" data-name="lookForBinder">
						lookForBinder  
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.randomString" title="Функция, которая возвращает уникальную псевдо-случайную строку" data-name="randomString">
						randomString  
					</a>
				</li>
			 
			
				<li>
					<a href="#Matreshka.binders" title="" data-name="binders">
						binders
						<span class="expand"></span>
						<span class="hidden-active-child"></span>
					</a>
					<div class="submenu-wrapper">
						<ul data-submenu="Matreshka.binders">
							
								<li>
									<a href="#Matreshka.binders.innerHTML" title="Возвращает односторонний привязчик, меняющий innerHTML DOM элемента в зависимости от значения свойства экземпляра класса" data-name="binders.innerHTML">
										innerHTML
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.visibility" title="Возвращает односторонний привязчик, меняющий видимость DOM элемент (используя style.display), в зависимости от значения свойства экземпляра класса" data-name="binders.visibility">
										visibility
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.className" title="Возвращает односторонний привязчик, который переключает имя класса DOM элемента в зависимости от значения свойства экземпляра класса. Если значение свойства нестрого равно true, имя класса добавляется, в противном случае - убирается. Логику можно изменить, добавив восклицательный знак перед именем класса, и, таким образом, имя класса будет добавляться, когда значение свойства нестрого равно false и наоборот." data-name="binders.className">
										className
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.property" title="Возвращает односторонний привязчик, меняющий свойство DOM элемента на значение свойства экземпляра класса" data-name="binders.property">
										property
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.attribute" title="Возвращает односторонний привязчик, меняющий атрибут DOM элемента на значение свойства экземпляра класса" data-name="binders.attribute">
										attribute
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.input" title="Возвращает двусторонний привязчик, связывающий свойство экземпляра класса с элементом input. Напрямую привязчик использовать не обязательно, так как он входит в список Matreshka.defaultBinders." data-name="binders.input">
										input
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.textarea" title="Возвращает двусторонний привязчик, связывающий свойство экземпляра с элементом textarea. Напрямую привязчик использовать не обязательно, так как он входит в список Matreshka.defaultBinders." data-name="binders.textarea">
										textarea
									</a>
								</li>
							
								<li>
									<a href="#Matreshka.binders.select" title="Возвращает двусторонний привязчик, связывающий свойство экземпляра с элементом select. Напрямую привязчик использовать не обязательно, так как он входит в список Matreshka.defaultBinders." data-name="binders.select">
										select
									</a>
								</li>
							 
						</ul>
					</div>
				</li>
			
		</ul>
	</div>

	<a href="#Matreshka.Object" data-name="Object">
		<b>Matreshka.Object</b>
		
		<i class="important" title="Важно"></i>
		<span class="expand"></span>
		<span class="hidden-active-child"></span>
	</a>
	<div class="submenu-wrapper">
		<ul data-submenu="Matreshka.Object">
			
				<li>
					<a href="#Matreshka.Object-isMKObject" title="Свойство isMKObject всегда равно true. Оно используется для проверки, является ли объект экземпляром Matreshka.Object." data-name="isMKObject">
						isMKObject 
					</a>
				</li>
			
			
				<li>
					<a href="#Matreshka.Object-keys" title="Возвращает массив ключей, отвечающих за данные" data-name="keys">
						keys
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-on" title="Работает так же, как и Matreshka#on, но дополнительно позволяет динамически навешивать обработчики на свойства, отвечающие за данные без прямого указания имени свойства" data-name="on">
						on
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-hasOwnProperty" title="Проверяет есть ли в экземпляре свойство, отвечающее за данные, с заданным ключем" data-name="hasOwnProperty">
						hasOwnProperty
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-toObject" title="Конвертирует экземпляр Matreshka.Object в обычный объект, но не конвертирует входящие в него свойства" data-name="toObject">
						toObject
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-toNative" title="Делает то же самое, что и Matreshka.Object#toObject" data-name="toNative">
						toNative
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-toJSON" title="Конвертирует экземпляр и внутренние свойства Matreshka.Object обычный объект" data-name="toJSON">
						toJSON
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-keyOf" title="Ищет заданное значение свойства среди свойств, отвечающих за данные и возвращает ключ, если такое значение найдено  (аналог Array.prototype.indexOf)" data-name="keyOf">
						keyOf
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-jset" title="Устанавливает свойство и добавляет ключ в список ключей, отвечающих за данные" data-name="jset">
						jset
						<i class="important" title="+self.lang.important+"></i>
						
							<span class="expand"></span>
							<span class="hidden-active-child"></span>
						
					</a>
					
						<div class="submenu-wrapper">
							<ul data-submenu="Matreshka.Object-jset">
								
									<li>
										<a href="#Matreshka.Object-jset(2)" title="Альтернативный синтаксис метода Matreshka.Object#jset, который использует объект ключ-значение для установки нескольких свойств сразу" data-name="jset#2">
											#2
										</a>
									</li>
								
							</ul>
						</div>
					
			
				<li>
					<a href="#Matreshka.Object-remove" title="Удаляет свойство из экземпляра класса Matreshka.Object и из списка ключей, отвечающих за данные" data-name="remove">
						remove
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-addDataKeys" title="Добавляет ключи в список ключей, отвечающих за данные" data-name="addDataKeys">
						addDataKeys
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-removeDataKeys" title="Удаляет ключи из списка ключей, отвечающих за данные (но не удаляет свойство)" data-name="removeDataKeys">
						removeDataKeys
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Object-each" title="Перебирает свойства, отвечающие за данные" data-name="each">
						each
						
						
					</a>
					
			
			 
			 
			
		</ul>
	</div>

	<a href="#Matreshka.Array" data-name="Array">
		<b>Matreshka.Array</b>
		
		<i class="important" title="Важно"></i>
		<span class="expand"></span>
		<span class="hidden-active-child"></span>
	</a>
	<div class="submenu-wrapper">
		<ul data-submenu="Matreshka.Array">
			
				<li>
					<a href="#Matreshka.Array-isMKArray" title="isMKArray всегда равен true. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса Matreshka.Array" data-name="isMKArray">
						isMKArray 
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.Array-useBindingsParser" title="Свойство включает экспериментальный парсер, если присвоить ему true" data-name="useBindingsParser">
						useBindingsParser 
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.Array-renderIfPossible" title="Свойство renderIfPossible отменяет рендеринг массива" data-name="renderIfPossible">
						renderIfPossible 
					</a>
				</li>
			
				<li>
					<a href="#Matreshka.Array-itemRenderer" title="HTML строка, селектор или функция, отвечающая за отрисовку элементов массива на странице" data-name="itemRenderer">
						itemRenderer <i class="important" title="+self.lang.important+"></i>
					</a>
				</li>
			
			
				<li>
					<a href="#Matreshka.Array-Model" title="Свойство определяет класс элементов, которые будет содержать коллекция" data-name="Model">
						Model
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-mediateItem" title="Трансформирует значение элемента при вставке" data-name="mediateItem">
						mediateItem
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-on" title="Работает так же, как и Matreshka#on, но дополнительно позволяет динамически навешивать обработчики на вставленные элементы." data-name="on">
						on
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-recreate" title="Пересоздает экземпляр Matreshka.Array" data-name="recreate">
						recreate
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-toArray" title="Конвертирует Matreshka.Array в обычный массив, но не конвертирует входящие в него элемены" data-name="toArray">
						toArray
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-toNative" title="Делает то же самое, что и Matreshka.Array#toArray" data-name="toNative">
						toNative
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-rerender" title="Перерисовывает DOM узлы элементов, входящих в массив" data-name="rerender">
						rerender
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-hasOwnProperty" title="Существует ли свойство в экземпляре (индекс или свойство length)" data-name="hasOwnProperty">
						hasOwnProperty
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-toJSON" title="Конвертирует экземпляр и элементы, входящие в него в обычный массив" data-name="toJSON">
						toJSON
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-pull" title="Удаляет элемент с заданным индексом из массива и возвращает этот элемент. Начиная с версии 0.3, метод поддерживает удаляемый элемент в качестве аргумента." data-name="pull">
						pull
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-each" title="Работает точно так же, как и метод forEach, который перебирает элементы массива" data-name="each">
						each
						
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-METHOD" title="Любой метод из Array.prototype" data-name="METHOD">
						METHOD
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
				<li>
					<a href="#Matreshka.Array-METHOD_" title="Любой метод из Array.prototype с возможностью передать объект события" data-name="METHOD_">
						METHOD_
						<i class="important" title="+self.lang.important+"></i>
						
					</a>
					
			
			 
			 
			
		</ul>
	</div>


<a href="#Class" title="Реализация классов, основанная на прототипном наследовании">
	Class 
	
</a>

<a href="#$b" title="Микро-библиотека Балалайка">
	$b 
	
</a>


	<a>Туториал (скоро)</a>
	<a href="#whats-new">Что нового?</a>
	<a href="#how-to-update">Обновление до 1.0</a>
	<a href="//matreshka.io" class="another-language"><i></i> English version</a>
</nav> 


<main>
	<section id="promo">
	<article id="home">
		<img src="img/mk1-logo.svg">
		<h1>Matreshka.js 0.3</h1>
		<p>JavaScript фреймворк для программистов</p>
		<pre class="prettyprint lang-html" style="max-width: 540px; margin: 0 auto; text-align: left;"><code>&lt;script src=&quot;matreshka.min.js&quot;&gt;&lt;/script&gt;
&lt;input type=&quot;text&quot; class=&quot;my-input&quot;&gt;
&lt;script&gt;
var app = new Matreshka;
app.bindNode( 'x', '.my-input' );
app.x = 'Двустороннее связывание данных в JS? Серьезно?';
&lt;/script&gt;</code></pre><!--Two-way data binding in JS? O rly?-->
		<p>
			<a href="https://raw.githubusercontent.com/finom/matreshka/master/matreshka.min.js" download class="download-btn">Скачать <i></i></a>
			<a href="https://github.com/finom/matreshka" class="github-btn">Github <i></i></a>
		</p>
	</article>
</section>
	<section>
<article id="introduction"><h2><a href="#introduction">Введение</a></h2><p>Матрешка - фреймворк для больших и бесконечно расширяемых приложений (в рамках Вселенной, конечно же), написанных на языке JavaScript. Он позволяет построить архитектуру программы так, чтоб ни вы ни ваша команда не запутались в многочисленных сущностях, в дебаггинге логики, описанной в HTML файле, многочисленных ограничениях других фреймворков и непонятных абстракциях.</p>
<p>Двухсторонняя привязка данных и представления осуществляется с помощью метода <a href="#Matreshka-bindNode">bindNode</a> исключительно в .js (или .es6) файлах и не требует менять HTML, добавляя чуждые {{синтаксические.конструкции}}. Программист, задав несколько правил, может продолжать работать с данными, забыв о состоянии видимой части приложения.</p>
<blockquote>
<p>Порядок не важен, вы можете объявить привязки после полной реализации логики, отвечающей за данные.</p>
</blockquote>
<p>Коллекции в Матрешке представлены классом <a href="#Matreshka.Array">Matreshka.Array</a>, экземпляры которого сами рендерят HTML при добавлении, удалении или изменении элементов. Вы можете сказать, что фреймворк X тоже отрисовывает элементы массива при изменении данных, но в Матрешке эта задача решается невероятно просто и элегантно.</p>
<p>Кроме всего прочего, Матрешка - очень лёгкий для понимания фреймворк. Любой разработчик, от новичка, умеющего писать простые штуки на JavaScript, до опытного ниндзи, разберется без проблем.</p>
<p>Сегодня <script>document.write(new Date().getFullYear());</script> год, это значит, что, наконец, пришло время фреймворка без ограничений, жестких правил и сомнительного синтаксиса. Пришло время фреймворка для программистов, которым умправляете вы, а не он управляет вами!</p></article><article id="getting-started"><h2><a href="#getting-started">С чего начать</a></h2><p>Все популярные фреймворки включает в себя множество удобных и интересных функций. Проблема в том, что новичку порой сложно понять, с чего начинать своё обучение. Изобилие функциональных возможностей того или иного фреймворка наводит на резонный вопрос: "Эй, я должен всё это выучить?".</p>
<p>В этой документации этот недочет решен. Для того, чтоб начать уверенно работать с фреймворком, нужно изучить классы, свойства и методы, помеченные, как важные, флажком <i class="important"></i> (их чуть больше десяти). Дальше, при желании, можно постепенно приступать к освоению остальных методов, добавляющих в ваш JavaScript код ту магию, о которой вы и не мечтали.</p>
<blockquote>
<p>Потрясающие возможности HTML5 не обошли стороной и эту страницу. Она доступна оффлайн для любого устройства, от вашего компьютера до мобильного телефона. </p>
<p><strong>Chrome для Android</strong>: зайдите в меню и нажмите "Добавить на главный экран" или "Add to home screen"</p>
<p><strong>Safari для iOS</strong>: нажмите на иконку "Action" и выберите "Add to Home Screen"</p>
<p><strong>Любые другие устройства</strong>: просто добавьте страницу в закладки </p>
<p>Теперь документацию к Матрешке можно читать без подключения к интернету. Если страница тормозит (замечено на Android 4.2), переключитесь в режим "По одному".</p>
</blockquote></article><article id="hello-world"><h2><a href="#hello-world">Hello World!</a></h2><p>Написать первое приложение с помощью фреймворка Матрешка очень просто. Для этого:</p>
<p><strong>1.</strong> Создайте HTML файл со следующим содержимым</p>
<pre class="prettyprint source lang-html"><code>&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
        &lt;title>Моё первое приложение на базе Матрешки&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;input type="text" class="my-input">
        &lt;div class="my-output">&lt;/div>
        &lt;script src="http://cdn.jsdelivr.net/matreshka/latest/matreshka.min.js">&lt;/script>
        &lt;script src="js/app.js">&lt;/script>
    &lt;/body>
&lt;/html></code></pre><p><strong>2.</strong> Напишите свой первый класс, наследующий Матрешку, создав файл <strong>js/app.js</strong></p>
<pre class="prettyprint source lang-js"><code>var Application = Class({
    'extends': Matreshka,
    constructor: function() {

        // связываем свойство x и текстовое поле
        this.bindNode( 'x', '.my-input' );

        // связываем свойство x и блок с классом my-output
        this.bindNode( 'x', '.my-output', {
            setValue: function( v ) {
                this.innerHTML = v;
            }
        });

        // если свойсово "х" изменилось, сообщаем об этом в консоли
        this.on( 'change:x', function() {
            console.log( 'x изменен на ' + this.x );
        });
    }
});

var app = new Application();</code></pre><p><strong>3.</strong> Это всё!</p>
<p>Теперь можете открыть консоль разработчика (клавиша F12) и написать:</p>
<pre class="prettyprint source lang-js"><code>app.x = 'Привет Мир!';</code></pre><p>Круто, не правда ли? Теперь можно работать напрямую со свойствами без болезненных инкапсуляций.</p>
<blockquote>
<p>Матрешка использует объектно-ориентированный подход основанный на классах, которые зарекомендовали себя самой с лучшей стороны в большинстве языков программирования: Python, C#, Java и многих других. Такое решение позволяет легко перейти на новые возможности синтаксиса JavaScript, описанные в стандарте ECMAScript 2015 и поддерживаемые Матрешкой. Проекты типа <a href="http://babeljs.io/">Babel</a> уже сегодня позволяют использовать крутой синтаксис JS нового поколения.</p>
<pre class="prettyprint source lang-js"><code>class Application extends Matreshka {
    constructor: function() {
        this.bindNode( 'x', '.my-input' );
        this.bindNode( 'x', '.my-output', {
            setValue: function( v ) {
                this.innerHTML = v;
            }
        });
        this.on( 'change:x', function() {
            console.log( 'x изменен на ' + this.x );
        });
    }
}</code></pre></blockquote>
<p><a href="http://jsbin.com/lalerebepo/2/edit?js,output">Живой пример</a> (нажмите кнопку "Run with JS", чтобы пример запустился)</p>
<h4>Ссылки</h4><ul>
<li><a href="#Matreshka">Класс Matreshka</a></li>
<li><a href="#Matreshka-bindNode">Метод Matreshka#bindNode</a></li>
<li><a href="#Matreshka-on">Метод Matreshka#on</a></li>
<li><a href="#Class">Функция Class</a></li>
</ul></article><article id="todomvc"><h2><a href="#todomvc">TodoMVC</a></h2><p>Как известно, самым эффективным способом понять, стоит ли изучать библиотеку или фрефмворк является код. Проект <a href="http://todomvc.com/">TodoMVC</a> объединяет десятки фреймворков позволяя их сравнить на примере одного и того же приложения.</p>
<p><img src="img/todomvc.png" alt="TodoMVC"></p>
<p>Посмотрите на <a href="todo/">живую реализацию TodoMVC</a> на базе Матрешки, а, затем, <a href="todo/js_ru/docs/app.html">взгляните на исходный код с аннотациями</a>. Выглядит очень просто, не так ли?</p></article><article id="how-to-include"><h2><a href="#how-to-include">Как подключить?</a></h2><p>Матрешка - самостоятельный фреймворк, не требующий никаких зависимостей. Но возможность использования уже не современных возможностей из стандарта ECMAScript5 в Internet Explorer 8 отсутствует. Поэтому, если вы поддерживаете IE8 в разрабатываемых вами приложениях, вам нужно подключить еще один JavaScript файл: <a href="https://github.com/es-shims/es5-shim">es5-shim</a> или любой другой полифил, реализующий возможности ECMAScript5.</p>
<p>Подкючение jQuery для всех браузеров - опционально (хотя, для IE8 рекомендуемо). Вместо этой библиотеки можете воспользоваться другой jQuery-подобной библиотекой, например, <a href="http://zeptojs.com/">Zepto</a>. Если вы вовсе не хотите использовать библиотек, отдавая предпочтение <a href="http://vanilla-js.com/">Vanilla.js</a>, Матрешка будет использовать встроенную микро-библиотеку, которая называется <a href="$b">Балалайка</a>.</p>
<pre class="prettyprint source lang-html"><code>&lt;!-- Обязательно для IE8 -->
&lt;script src="js/es5-shim.min.js">&lt;/script> 
&lt;script src="js/matreshka.min.js">&lt;/script></code></pre><p>Кроме этого, Матрешка поддерживает AMD, например, require.js или almond</p>
<pre class="prettyprint source lang-js"><code>require(['path/to/matreshka'], function(Matreshka) {
    //...
});</code></pre><p>Импорт в стиле EcmaScript6 (используя Babel)</p>
<pre class="prettyprint source lang-js"><code>import Matreshka from 'path/to/matreshka';</code></pre></article>
</section>

	<section>
	<article class="item class" id="Matreshka">
		<h2>
			<a href="#Matreshka">
				<span class="signature-class">Класс</span> Matreshka
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p>Класс Matreshka - ядро фреймворка Matreshka.js, от которого наследуются <a href="#Matreshka.Array">Matreshka.Array</a>, <a href="#Matreshka.Object">Matreshka.Object</a> и каждый класс создаваемого приложения. Он содержит основной функционал фреймворка, среди которого есть несколько полезнейшх функций: <a href="#Matreshka-mediate">медиаторы</a>, <a href="#Matreshka-linkProps">зависимости</a>, <a href="#Matreshka-bindNode">привязки к DOM</a>, <a href="#Matreshka-on">движок событий</a> и пр. Наследование этого класса, как и наследование любого другого класса, осуществляется при помощи функции <a href="#Class">Class</a>.</p>
<p>Как правило, этот класс, (как и <a href="#Matreshka.Array">Matreshka.Array</a> и <a href="#Matreshka.Object">Matreshka.Object</a>), не используются напрямую. Вместо этого, от него наследуются классы, создаваемые вами. Поэтому, примеры к свойствам и методам в этой документации, как правило, будут приведены с использованием ключевого слова <code>this</code>.</p>
		</div>
		
		
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Class">Class</a>
	
</ul>


		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>var mk = new Matreshka;</code></pre><h5><p>Краткая запись: MK вместо Matreshka</p></h5>
<pre class="prettyprint source lang-js"><code>var mk = new MK;</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Матрешка использует прототипы для реализации наследования. Функция <a href="#Class">Class</a> лишь вносит синтаксический сахар и добавляет хаки для Internet Explorer 8. Поэтому вы можете воспользоваться любым другим полюбившимся способом наследования, например, используя классы из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre>
		<a class="comments" data-id="Matreshka" data-title="Класс Matreshka">Задать вопрос<i></i></a>
<div class="comments-container"></div>
	</article>
	
<article class="item property" id="Matreshka-isMK">
	<h2>
		<a href="#Matreshka-isMK">
			
			<span class="memberof">Matreshka#</span>isMK</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p><code>isMK</code> всегда равен <code>true</code>. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса <a href="#Matreshka">Matreshka</a></p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(object.isMK);</code></pre>
	<a class="comments" data-id="Matreshka-isMK" data-title="Свойство Matreshka-isMK">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
	
<article class="item method " id="Matreshka-on">
	<h2>
		<a href="#Matreshka-on">
			<span class="memberof">Matreshka#</span>on<wbr>(<span class="args">names, callback, triggerOnInit<span class="default-value">=false</span>, context</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события</p></div>
	<div class="description"><p>Метод <a href="#Matreshka-on">Matreshka#on</a> добавляет обработчик события для экземпляра класса <code>Matreshka</code>. Полный список возможных событий с описанием см. здесь: <span data-type="eventNames">eventNames</span>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					<td> 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> <p>Имя события или несколько имен, разделенных пробелом  (например, <code>&quot;change:x ajaxcomplete change:y&quot;</code>)</p></td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					<td> 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> <p>Функция, которая вызывается по событию</p></td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Если аргумент <code>triggerOnInit</code> равен <code>true</code>, то обработчик будет вызван немедленно после инициализации.</p></td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					<td> 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Контекст обработчика. Другими словами, <code>this</code> при вызове <code>callback</code></p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#Matreshka-once">Matreshka#once</a>
	
		<li><a href="#Matreshka-off">Matreshka#off</a>
	
		<li><a href="#Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'foo', function() {
	alert( 'Custom Event is fired' );
});

this.trigger( 'foo' );</code></pre><h5><p>Передача контекста</p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'foo', function() {
	alert( this.a ); // 5
}, { a: 5 } );

this.trigger( 'foo', 'Hello world' );</code></pre><h5><p>Вызов обработчика сразу после инициализации</p></h5>
<pre class="prettyprint source lang-js"><code>//Выводит на экран "bar" сиюсекундно и ждет генерации события "foo"
this.on( 'foo', function() {
	alert( 'bar' );
}, true );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-on" data-title="Метод Matreshka-on">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-onDebounce">
	<h2>
		<a href="#Matreshka-onDebounce">
			<span class="memberof">Matreshka#</span>onDebounce<wbr>(<span class="args">names, callback, debounceDelay<span class="default-value">=0</span>, triggerOnInit<span class="default-value">=false</span>, context</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени</p></div>
	<div class="description"><p>Метод позволяет добавить обработчик события на экземпляр класса <a href="#Matreshka">Matreshka</a>, устраняя "дребезжание" обработчика. Функция может быть вызвана лишь один раз за определенный промежуток времени. В остальном, метод работает так же, как и <a href="#Matreshka-on">Matreshka#on</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					<td> 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> <p>Имя события или несколько имен, разделенных пробелом  (например, <code>&quot;change:x ajaxcomplete change:y&quot;</code>).</p></td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					<td> 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> <p>Функция, которая вызывается по событию</p></td>
				</tr>
			 
				<tr>
					<td>
						debounceDelay
						
							<span class="signature">optional</span>
						
					</td>
					<td> 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> <p>Задержка</p></td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Если аргумент <code>triggerOnInit</code> равен <code>true</code>, то обработчик будет вызван немедленно после инициализации</p></td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					<td> 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Контекст обработчика. Другими словами, <code>this</code> при вызове <code>callback</code></p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-on">Matreshka#on</a>
	
		<li><a href="#Matreshka-once">Matreshka#once</a>
	
		<li><a href="#Matreshka-off">Matreshka#off</a>
	
		<li><a href="#Matreshka-trigger">Matreshka#trigger</a>
	
		<li><a href="#Matreshka.debounce">Matreshka.debounce</a>
	
		<li><a href="http://habrahabr.ru/post/60957/">Статья на Хабре микропаттерне debounce</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.onDebounce( 'change:x', function() {
	alert( 'x = ' + this.x ); // x = 100
}, 300 );

this.x = 1;

for( var i = 0; i &lt; 100; i++ ) {
	this.x++;
}</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-onDebounce" data-title="Метод Matreshka-onDebounce">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-once">
	<h2>
		<a href="#Matreshka-once">
			<span class="memberof">Matreshka#</span>once<wbr>(<span class="args">names, callback, context</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработик событий, который может быть вызван однажды</p></div>
	<div class="description"><p>Метод работает так же, как и <a href="#Matreshka-on">Matreshka#on</a> но передаваемый обработчик может быть вызван только один раз.
Обратите внимание, что у метода отсутствует аргумент <code>triggerOnInit</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> <p>Имя события или несколько имен, разделенных пробелом (например, <code>&quot;change:x ajaxcomplete change:y&quot;</code>)</p></td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> <p>Функция, которая вызывается по событию</p></td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Контекст обработчика</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-on">Matreshka#on</a>
	
		<li><a href="#Matreshka-off">Matreshka#off</a>
	
		<li><a href="#Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.x = 1;

this.once( 'change:x', function() {
	alert( 'x is changed' );
});

this.x = 2; // выводит 'x is changed'

this.x = 3; // ничего не делает</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-once" data-title="Метод Matreshka-once">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-off">
	<h2>
		<a href="#Matreshka-off">
			<span class="memberof">Matreshka#</span>off<wbr>(<span class="args">names, callback, context</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет обработчик события</p></div>
	<div class="description"><p>Удаляет созданный ранее обработчик. Все три аргумента опциональны. Вы можете удалить как все события (не передавая ни одного аргумента), так и отдельные (передав только имя события, передав имя события и обработчик, передав и имя события, и обработчик, и контекст)</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> <p>Разделенный пробелами список имен событий (например, <code>&quot;change:x ajaxcomplete change:y&quot;</code>)</p></td>
				</tr>
			 
				<tr>
					<td>
						callback
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> <p>Функция-обработчик</p></td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Контекст</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-on">Matreshka#on</a>
	
		<li><a href="#Matreshka-once">Matreshka#once</a>
	
		<li><a href="#Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.off( 'change:x bind' );</code></pre><h5><p>Удаление всех событий</p></h5>
<pre class="prettyprint source lang-js"><code>this.off();</code></pre><h5><p>Удаление события с определенным обработчиком</p></h5>
<pre class="prettyprint source lang-js"><code>var handler = function() { 
	//...
}
this.on( 'change:x', handler );
this.off( 'change:x', handler );</code></pre><h5><p>Удаление события с определенным контекстом</p></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
this.on( 'change:x', handler, object );
this.off( 'change:x', handler, object );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-off" data-title="Метод Matreshka-off">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-trigger">
	<h2>
		<a href="#Matreshka-trigger">
			<span class="memberof">Matreshka#</span>trigger<wbr>(<span class="args">names, arg</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Генерирует событие</p></div>
	<div class="description"><p>После добавление обработчиков событий с помощью метода <a href="#Matreshka-on">Matreshka#on</a>, <a href="#Matreshka-onDebounce">Matreshka#onDebounce</a> или <a href="#Matreshka-once">Matreshka#once</a>, событие можно генерировать вручную с помощью этого метода.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> <p>Имя события или несколько имен, разделенных пробелом</p></td>
				</tr>
			 
				<tr>
					<td>
						arg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Аргументы, которые будут переданы обработчикам</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-on">Matreshka#on</a>
	
		<li><a href="#Matreshka-once">Matreshka#once</a>
	
		<li><a href="#Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#Matreshka-off">Matreshka#off</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'jigurda ohyeah', function( a, b, c ) {
	alert( a, b, c );
});
this.trigger( 'ohyeah', 1, 2, 3 ); // alerts 6</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-trigger" data-title="Метод Matreshka-trigger">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-bindNode">
	<h2>
		<a href="#Matreshka-bindNode">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">key, node, binder, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Связывает свойство объекта с HTML элементом</p></div>
	<div class="description"><p><a href="#Matreshka-bindNode">Matreshka#bindNode</a> - это единственный метод класса <a href="#Matreshka">Matreshka</a>, отвечающий за изменения DOM. Он создаёт мост между значением свойства и состоянием HTML элемента на странице: от простого инпута до сложного виджета (сложность элементов не ограничена). <code>bindNode</code>, по праву, можно назвать главным методом фреймворка. После связывания свойства экземпляра и HTML элемента не нужно больше следить за синхронизацией данных и представления. </p>
<p>Для двустороннего связывания элемента и значения свойства, в метод передаются три аргумента: <strong>имя свойства</strong> (ключ), <strong>HTML элемент</strong> (или селектор) и <strong>правило привязки</strong> (синонимы: байндер, биндер, binder, привязчик). Байндер, в свою очередь, является обычным объектом и может иметь следующие свойства: <code>on</code>, <code>getValue</code>, <code>setValue</code>, <code>initialize</code> (подробнее см. <span data-type="binder">binder</span>). Все четыре свойства - опциональны. Это позволяет также объявить и односторонние привязки.</p>
<blockquote>
<p>Метод <code>bindNode</code> поддерживает привязки "многие ко многим". С одним свойством можно связать несколько элементов, а с одним элементом можно связать несколько свойств, в том числе и от разных экземпляров разных классов.</p>
</blockquote>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element'. {
    on: 'click',
    getValue: function() { ... },
    setValue: function() { ... }
});</code></pre><p>Например, вы хотите связать свойство объекта с элементом <code>input[type="checkbox"]</code>:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-checkbox'. {
    // когда менятся состояние элемента?
    // - по событию 'click'
    on: 'click',
    // как извлечь состояние элемента?
    // - вернуть значение 'checked'
    getValue: function() {
        return this.checked;
    },
    // как установить состояние элемента?
    // - установить значение 'checked'
    setValue: function( v ) {
        this.checked = !!v;
    }
});</code></pre><p>После объявления привязки можно устанавливать значение свойства объекта самым привычным способом, а элемент (в данном случае, чекбокс) моментально изменит своё состояние. При клике на чекбокс, значение свойства тоже изменится на соответствующее.</p>
<pre class="prettyprint source lang-js"><code>// устанавливает checked = false
this.myKey = true;</code></pre><blockquote>
<p>Если значение свойства экземпляра класса не задано, Матрешка, после привязки, попробует извлечь это значение из HTML узла, используя <code>getValue</code>. Отменить это поведение можно передав свойство <code>assignDefaultValue: false</code> в объект события.</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element', binder, {
    assignDefaultValue: false
});</code></pre></blockquote>
<p>Более сложный пример: связывание свойства объекта с виджетом jQuery UI</p>
<pre class="prettyprint source lang-html"><code>&lt;div class="my-slider">&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-slider', {
    // когда менятся состояние элемента?
    // - по событию 'slide'
    on: 'slide',
    // как извлечь состояние элемента?
    // - вернуть значение виджета 'value'
    getValue: function() {
        return $( this ).slider( 'option', 'value' );
    },
    // как установить состояние элемента?
    // - установить значение 'value'
    setValue: function( v ) {
        $( this ).slider( 'option', 'value', v );
    },
    // как инициализировать виджет?
    // инициализировать слайдер можно любым способом,
    // но initialize предоставляет немного синтаксического сахара
    initialize: function() {
        $( this ).slider({ min: 0, max: 100 });
    }
});</code></pre><pre class="prettyprint source lang-js"><code>// установит знчаение слайдера 42
this.myKey = 42;</code></pre><p>Выглядит просто, но вы, скорее всего, задаётесь вопросом: "Как сделать так, чтоб мне не пришлось каждый раз прописывать эти правила?". Вопрос очень правильный. Действительно, на странице может быть очень много однотипных элементов: текстовых полей, выпадающих меню, новых полей из спецификации HTML5, могут быть и сторонние виджеты (о чем говорит пример выше).</p>
<p>Как видно из документации к аргументам метода <a href="#Matreshka-bindNode">Matreshka#bindNode</a> (см. ниже), третий аргумент не обязателен. Этот вопрос решает массив <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>, который содержит функции, проверяющие HTML элемент на соответствие заданным правилам. Вы получаете возможность многократно сократить код, вынося правила привязки в отдельную часть вашего кода, а для привязки использовать синтаксис без третьего аргумента:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );</code></pre><p>Как это сделать? Нужно добавить функцию, проверяющую ваш элемент на соответствие некоторым правилам в начало массива <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>. Пример ниже можно использовать в качестве шаблона для создания своего стандартного байндера.</p>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
// это нужно для того, чтоб сохранить возможность переопределения
Matreshka.binders.checkbox = function() {
    return {
        on: 'click',
        getValue: function() {
            return this.checked;
        },
        setValue: function( v ) {
            this.checked = !!v;
        }
    }
};

// метод shift добавляет функцию в начало массива Matreshka.defaultBinders
Matreshka.defaultBinders.shift( function( node ) {
    // проверяем, является ли элемент чекбоксом
    if( node.tagName == 'INPUT' && node.type == 'checkbox' ) {
        // если проверка пройдена, возвращаем новый байндер
        return Matreshka.binders.checkbox();
    }
});</code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-checkbox' );
this.myKey = true;</code></pre><p>Что делать, если вам нужно передать аргументы для инициализации какого-нибудь плагина или виджета? Всё очень просто: можно ограничиться добавлением байндера в коллекцию <a href="#Matreshka.binders">Matreshka.binders</a>, не создавая функцию для <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p>
<pre class="prettyprint source lang-js"><code>Matreshka.binders.uiSlider = function( min, max ) {
    return {
        on: 'slide',
        getValue: function() {
            return $( this ).slider( 'option', 'value' );
        },
        setValue: function( v ) {
            $( this ).slider( 'option', 'value', v );
        },
        initialize: function() {
            $( this ).slider({ min: min, max: max });
        }
    }
};</code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey1', '.my-slider1', Matreshka.binders.uiSlider( 0, 100 ) );
this.bindNode( 'myKey2', '.my-slider2', Matreshka.binders.uiSlider( 1, 1000 ) );
this.myKey1 = 42;
this.myKey2 = 999;</code></pre><p><a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a> из коробки, начиная с версии 0.3, содержит поддержку <strong>всех без исключения</strong> HTML элементов форм: <code>select</code> (включая <code>multiple</code>), <code>textarea</code>, <code>input</code> (в том числе и все типы из спецификации HTML5: <code>text</code>, <code>checkbox</code>, <code>radio</code>, <code>range</code>, <code>number</code>, <code>date</code>, <code>search</code>, <code>time</code>, <code>datetime</code>, <code>datetime-local</code>, <code>color</code> и остальных). Это значит, что для стандартных элементов указывать байндер вовсе не обязательно.</p>
<pre class="prettyprint source lang-html"><code>&lt;input type="color" class="my-color-input"></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'myColor', '.my-color-input' );
this.myColor = '#66bb6a';</code></pre><p>Кроме всего, после привязки, вам доступен новый нестандартный CSS селектор <code>:bound(KEY)</code>.</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );

// найдет элемент '.my-inner-element' внутри '.my-element'
this.bindNode( 'myAnotherKey', ':bound(myKey) .my-inner-element' );</code></pre><p>И расширяется синтаксис возможных имен событий:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );

// отловит клик на элементе .my-element
this.on( 'click::myKey', functinon() { ... });

// отловит клик на элементе .my-inner-element
this.on( 'click::myKey(.my-inner-element)', functinon() { ... });</code></pre><h4>Создание песочницы</h4><p><a href="#Matreshka-bindNode">Matreshka#bindNode</a> умеет ассоциировать экземпляр класса с "главным" HTML элементом на странице, создавая так называемую <strong>песочницу</strong>. Это нужно для того, чтоб ограничить влияние экземпляра на HTML элементы, содержащиеся в другой песочнице (т. е. в другом HTML элементе). Для привязки песочницы используется специальное свойство <code>'sandbox'</code>.</p>
<pre class="prettyprint source lang-html"><code>&lt;div class="my-sandbox">
    &lt;!-- your HTML code -->
&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.my-sandbox' );</code></pre><p>Определение песочницы добавляет множество удобств программисту. Например:</p>
<ul>
<li>Позволяет использовать методы <a href="#Matreshka-select">Matreshka#select</a> и <a href="#Matreshka-$">Matreshka#$</a></li>
<li>Позволяет использовать методы <a href="#Matreshka-bound">Matreshka#bound</a> и <a href="#Matreshka-$bound">Matreshka#$bound</a> без указания аргумента</li>
<li>Добавляет новый селектор <code>:sandbox</code> в методах <a href="#Matreshka-bindNode">Matreshka#bindNode</a>, <a href="#Matreshka-select">Matreshka#select</a>, <a href="#Matreshka-$">Matreshka#$</a> и других</li>
<li>Добавляет синтаксический сахар для делегированных DOM событий в методе <a href="#Matreshka-on">Matreshka#on</a></li>
</ul>
<pre class="prettyprint source lang-js"><code>// объявляем песочницу
this.bindNode( 'sandbox', '.my-sandbox' );

// .my-element ищется в песочнице
this.bindNode( 'myKey', ':sandbox .my-element' );

// для делегированных событий внутри песочницы не требуется указывать ключ
this.on( 'click::(.my-button)', function() { ... } );

// выведет в консоль элемент песочницы
console.log( this.$bound() );

// выведет в консоль элемент .inner-node, который находится внутри песочницы
console.log( this.$( '.inner-node' ) );</code></pre></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">bind</span> <span class="event">bind:KEY</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="matreshka">matreshka</span>
</td>
					<td> <p>Ключ (имя свойства)</p></td>
				</tr>
			 
				<tr>
					<td>
						node
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="node">node</span>

	<span data-type="$nodes">$nodes</span>
</td>
					<td> <p>HTML элемент, который должен быть связан со свойством экземпляра</p></td>
				</tr>
			 
				<tr>
					<td>
						binder
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="binder">binder</span>
</td>
					<td> <p>Байндер (привязчик), содержащий следующие свойства: <code>on</code> - какое событие должно произойти на HTML элементе, говорящее о том, что пользователь что-то изменил (например, <code>keyup</code> или <code>click</code>), <code>getValue</code> - как извлечь значение из HTML элемента, <code>setValue</code> - как установить новое значение элементу и <code>initialize</code> - функция, выполняющаяся однажды, при инициализации привязки. Более подробно о привязчиках можно найти в документации к ним: см. <span data-type="binder">binder</span>.</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события, в который можно передать ключ <code>&quot;silent&quot;</code> (не генерировать события <code>&quot;bind&quot;</code> и <code>&quot;bind:KEY&quot;</code>), <code>&quot;assignDefaultValue&quot;</code> или другие данные</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-unbindNode">Matreshka#unbindNode</a>
	
		<li><a href="#Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a>
	
		<li><a href="#Matreshka-$">Matreshka#$</a>
	
		<li><a href="#Matreshka-$bound">Matreshka#$bound</a>
	
		<li><a href="#Matreshka.binders">Matreshka.binders</a>
	
		<li><a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>Кастомный чекбокс. Этот пример демонстрирует создание кастомного элемента, по клику на который у него меняется класс <code>&quot;checked&quot;</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $( this ).hasClass( 'checked' );
	},
	setValue: function( v ) {
		$( this ).toggleClass( 'checked', !!v );
	},
	// инициализируем поведение элемента
	// по клику на элемент меняется наличие класса 'checked'
	initialize: function() {
		$( this ).on( 'click', function() {
			$( this ).toggleClass( 'checked' );
		});
	}
});</code></pre><h5><p>Кастомный чекбокс 2. Этот пример повторяет предыдущий, но использует <a href="#Matreshka-defaultBinders">Matreshka#defaultBinders</a>, и проверяет элемент на наличие класса <code>custom-checkbox</code>. Если проверка пройдена, возвращает байндер</p></h5>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).on( 'click', function() {
				$( this ).toggleClass( 'checked' );
			});
		}
	}
};

MK.defaultBinders.shift( function( element ) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode( 'myKey', '.my-custom-checkbox' );</code></pre><h5><p>Событие <code>&quot;bind&quot;</code>, которое генерируется после связыввании любого свойства и HTML узла</p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'bind', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"</code></pre><h5><p>Событие <code>&quot;bind:KEY&quot;</code>, которое генерируется при связыввании конкретного свойства и HTML узла</p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'bind:myKey', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"</code></pre><h5><p>Подмена DOM события для стандартного байндера. Например, мы хотим связать <code>input[type=&quot;text&quot;]</code> со свойством. По умолчанию, стандартный байндер для этого элемента содержит свойство <code>&quot;on&quot;</code> со значением <code>&quot;keydown paste&quot;</code>. Это значит, что значение свойства экземпляра и состояние элемента будут синхронизированы, когда пользователь отпускает клавишу клавиатуры или вставляет содержимое из буфера обмена. В случае, если вы хотите, чтоб синхронизация происходила по DOM событию <code>&quot;blur&quot;</code>, вам потребуется передать третьим аргументом объект, содержащий единственное свойство <code>&quot;on&quot;</code>. Этот объект объединится со стандартным байндером, сохранив при этом значения <code>getValue</code> и <code>setValue</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-input', { on: "blur" });</code></pre><h5><p>Если элемент не найден, бросается исключение <code>&quot;Bound element is missing&quot;</code>. Для того, чтоб избежать ошибки используйте метод <a href="#Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a></p></h5>
<pre class="prettyprint source lang-js"><code>var $el = $();
this.bindNode( 'x', $el ); // Ошибка, так как $el пуст</code></pre><h5><p>Синхронизация значения свойства и HTML содержимого элемента</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.innerHTML = v;
	}
});

// можно сделать проще
this.bindNode( 'myKey', '.my-element', MK.binders.innerHTML() );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode" data-title="Метод Matreshka-bindNode">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-bindNode(2)">
	<h2>
		<a href="#Matreshka-bindNode(2)">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">keyElementPairs, binder, eventOptions</span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис: пары &quot;ключ-элемент&quot;</p></div>
	<div class="description"><p>Метод <a href="#Matreshka-bindNode">Matreshka#bindNode</a> можно передать объект с парами ключ-элемент, чтобы избежать многократного вызова метода и сократить код</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyElementPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>(см. пример)</p></td>
				</tr>
			 
				<tr>
					<td>
						binder
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="binder">binder</span>
</td>
					<td> <p>(см. выше)</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>(см. выше)</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode(2)" data-title="Метод Matreshka-bindNode(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-bindNode(3)">
	<h2>
		<a href="#Matreshka-bindNode(3)">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">setOfArguments, eventOptions</span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис &quot;куча аргументов&quot;</p></div>
	<div class="description"><p>Еще один синтаксис для метода <a href="#Matreshka-bindNode">Matreshka#bindNode</a>. Этот способ может показаться непривлекательным, но, иногда, есть нужда привязать много элементов с различными байндерами за один присест. С таким синтаксисом вы можете присвоить определенные байндеры какой-нибудь переменной, затем легко удалить все и сразу, используя <a href="#Matreshka-unbindNode">Matreshka#unbindNode</a>.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						setOfArguments
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> <p>Массив массивов аргументов (см. пример)</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>(см. выше)</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode(3)" data-title="Метод Matreshka-bindNode(3)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka-bindOptionalNode">
	<h2>
		<a href="#Matreshka-bindOptionalNode">
			<span class="memberof">Matreshka#</span>bindOptionalNode<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает в точности так же, как и <a href="#Matreshka-bindNode">Matreshka#bindNode</a> но не бросает исключение, если аргумент <code>node</code> - пустой массив, <code>undefined</code> или не существует</p></div>
	<div class="description"></div>
	
	
	
	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindOptionalNode( 'myKey', '.my-element' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindOptionalNode" data-title="Метод Matreshka-bindOptionalNode">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-unbindNode">
	<h2>
		<a href="#Matreshka-unbindNode">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">key, node, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Разрывает связь между свойством и HTML элементом</p></div>
	<div class="description"><p>Используя этот метод, можно удалить недавно добавленную, но уже не нужную связь между свойством и элементом.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">unbind</span> <span class="event">unbind:KEY</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="null">null</span>
</td>
					<td> <p>Ключ или список ключей, разделенных пробелами. Если вместо ключа передать null, удалятся все привязки для данного экземпляра</p></td>
				</tr>
			 
				<tr>
					<td>
						node
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="node">node</span>

	<span data-type="$nodes">$nodes</span>
</td>
					<td> <p>HTML элемент, с которым свойство больше не хочет иметь дела</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события, в который можно передать какие-нибудь данные для обработика или ключ <code>&quot;silent&quot;</code>, который отключает генерацию событий <code>&quot;unbind&quot;</code> и <code>&quot;unbind:KEY&quot;</code></p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );

// меняет значение свойства и состояние HTML элемента
this.myKey = true; 

this.unbindNode( 'myKey', '.my-element' );

// теперь меняется только значение свойства
this.myKey = false; </code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode" data-title="Метод Matreshka-unbindNode">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-unbindNode(2)">
	<h2>
		<a href="#Matreshka-unbindNode(2)">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">keyElementPairs, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис <a href="#Matreshka-unbindNode">Matreshka#unbindNode</a> &quot;ключ-элемент&quot; для <a href="#Matreshka-unbindNode">Matreshka#unbindNode</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyElementPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>(см. пример)</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>(см. выше)</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode(2)">Matreshka#bindNode(2)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.unbindNode({
	myKey1: '.my-element1' 
	myKey1: '.my-element2' 
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode(2)" data-title="Метод Matreshka-unbindNode(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-unbindNode(3)">
	<h2>
		<a href="#Matreshka-unbindNode(3)">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">setOfArguments, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис <a href="#Matreshka-unbindNode">Matreshka#unbindNode</a> &quot;большая куча аргументов&quot;</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						setOfArguments
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> <p>Массив массивов аргументов (см. пример)</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>(см. выше)</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode(3)">Matreshka#bindNode(3)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode( temporaryBindings );

// больше не нужны эти привязки
this.unbindNode( temporaryBindings );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode(3)" data-title="Метод Matreshka-unbindNode(3)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-boundAll">
	<h2>
		<a href="#Matreshka-boundAll">
			<span class="memberof">Matreshka#</span>boundAll<wbr>(<span class="args">key</span>)
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает коллекцию привязанных элементов</p></div>
	<div class="description"><p>После привязки свойств и HTML элементов, можно получить коллекцию этих элементов с помощью метода <code>boundAll</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Привязанные элементы

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ свойства (или список ключей, разделенных пробелами), чьи привязанные элементы мы хотим получить. Если аргумент не передан, вернется элемент, являющийся песочницей для экземпляра</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );
this.boundAll( 'myKey' ); // вернет $( '.my-element' )</code></pre><h5><p>Возврат песочницы</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.app' );
this.boundAll(); // вернет $( '.app' )</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-boundAll" data-title="Метод Matreshka-boundAll">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-$bound">
	<h2>
		<a href="#Matreshka-$bound">
			<span class="memberof">Matreshka#</span>$bound<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#Matreshka-boundAll">Matreshka#boundAll</a></p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.$bound( 'myKey' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-$bound" data-title="Метод Matreshka-$bound">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-bound">
	<h2>
		<a href="#Matreshka-bound">
			<span class="memberof">Matreshka#</span>bound<wbr>(<span class="args">key</span>)
		</a> <span class="returns">→ 
	<span data-type="node">node</span>

	<span data-type="null">null</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает первый привязанный элемент или null</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

	<span data-type="null">null</span>

		 - Привязанный элемент

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ свойства (или список ключей, разделенных пробелами), чей привязанный элемент мы хотим получить. Если аргумент не передан, вернется элемент, являющийся песочницей для экземпляра</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );
this.bound( 'mykey' ); // вернет $( '.my-element' )[0]</code></pre><h5><p>Возврат &quot;песочницы&quot;</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.app' );
this.bound(); // вернет $( '.app' )[0]</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bound" data-title="Метод Matreshka-bound">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-selectAll">
	<h2>
		<a href="#Matreshka-selectAll">
			<span class="memberof">Matreshka#</span>selectAll<wbr>(<span class="args">Cелектор</span>)
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элементы из песочницы, соответствующие селектору</p></div>
	<div class="description"><p>После создания песочницы методом <a href="#Matreshka-bindNode">Matreshka#bindNode</a>, можно получать и использовать элементы, находящиеся в ней. Кроме этого, метод поддерживает  селектор <code>:bound(KEY)</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						Cелектор
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.app' );
this.selectAll( '.my-element' );
// то же самое, что и
this.$bound().find( '.my-element' );
// и то же самое, что и
$( '.app' ).find( '.my-element' );</code></pre><h5><p>Селектор <code>:bound(KEY)</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-element' );
this.selectAll( ':bound(myKey) .my-another-element' );
// то же самое, что и
this.$bound( 'myKey' ).find( '.my-another-element' );
// и то же самое, что и
$( '.my-element' ).find( '.my-another-element' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-selectAll" data-title="Метод Matreshka-selectAll">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-$(instance)">
	<h2>
		<a href="#Matreshka-$(instance)">
			<span class="memberof">Matreshka#</span>$<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#Matreshka-selectAll">Matreshka#selectAll</a></p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.$( '.my-element' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-$(instance)" data-title="Метод Matreshka-$(instance)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-select">
	<h2>
		<a href="#Matreshka-select">
			<span class="memberof">Matreshka#</span>select<wbr>(<span class="args">Селектор</span>)
		</a> <span class="returns">→ 
	<span data-type="node">node</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элемент из песочницы, соответствующий селектору</p></div>
	<div class="description"><p>Метод очнеь похож на <a href="#Matreshka-selectAll">Matreshka#selectAll</a>, но возвращает лишь один элемент или <code>null</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						Селектор
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.app' );
this.select( '.my-element' );
// то же самое, что и
this.bound().querySelector( '.my-element' );
// и то же самое, что и
$( '.app' ).find( '.my-element' )[ 0 ];</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-select" data-title="Метод Matreshka-select">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-eq">
	<h2>
		<a href="#Matreshka-eq">
			<span class="memberof">Matreshka#</span>eq<wbr>(<span class="args">object</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Проверяет экземпляр на равенство другому объекту</p></div>
	<div class="description"><p>Internet Explorer 8 бросает исключение при попытке традиционного сравнения на равенство, используя <code>==</code> или <code>===</code>. Метод <code>.eq</code> решает эту проблему. Если поддержка IE8 не нужна, то метод использовать не обязательно.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						object
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект, с которым нужно сравнить экземпляр</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.eq( object ); // true или false</code></pre><h5><p>Ошибка в IE8</p></h5>
<pre class="prettyprint source lang-js"><code>this === object; //иногда IE8 выкидывает "Class doesn't support Automation"</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-eq" data-title="Метод Matreshka-eq">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-defineGetter">
	<h2>
		<a href="#Matreshka-defineGetter">
			<span class="memberof">Matreshka#</span>defineGetter<wbr>(<span class="args">key, getter</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный геттер для свойства</p></div>
	<div class="description"><p>Этот метод позволяет установить геттер (getter), используя нативный метод <code>Object.defineProperty</code> и работает во всех браузерах, начиная с Internet Explorer 8. Возвращаемое значение свойства вычисляется при каждом обращении к свойству, поэтому более предпочтительным методом, с точки зрения производительности, является <a href="#Matreshka-linkProps">Matreshka#linkProps</a>.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ свойства, для которого устанавливается геттер</p></td>
				</tr>
			 
				<tr>
					<td>
						getter
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция-геттер</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineGetter( 'myKey', function() {
	return 42; // функция может возвращать любое вычисляемое значение
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineGetter" data-title="Метод Matreshka-defineGetter">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-defineGetter(2)">
	<h2>
		<a href="#Matreshka-defineGetter(2)">
			<span class="memberof">Matreshka#</span>defineGetter<wbr>(<span class="args">keyGetterPairs</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#Matreshka-defineGetter">Matreshka#defineGetter</a> для установки геттера &quot;ключ-геттер&quot;</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyGetterPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект со свойствами ключ-геттер</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineGetter({
	myKey1: function() { return 1; } 
	myKey2: function() { return 2; } 
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineGetter(2)" data-title="Метод Matreshka-defineGetter(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-defineSetter">
	<h2>
		<a href="#Matreshka-defineSetter">
			<span class="memberof">Matreshka#</span>defineSetter<wbr>(<span class="args">key, setter</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный сетер для свойства</p></div>
	<div class="description"><p>Этот метод позволяет установить сеттер (setter), используя нативный метод <code>Object.defineProperty</code> и работает во всех браузерах, начиная с Internet Explorer 8. При использовании этого метода следует иметь в виду, что он переписывет встроенный Матрешкой сеттер и, таким образом убирает возможность отлова событий, типа <code>change:КЛЮЧ</code>. Используйте этот метод только если точно знаете, что делаете. Медоды <a href="#Matreshka-on">Matreshka#on</a> и <a href="#Matreshka-mediate">Matreshka#mediate</a> безопасны с точки зрения стабильности создаваемого приложения, лучше используйте их.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ, для которого требуется установить сеттер</p></td>
				</tr>
			 
				<tr>
					<td>
						setter
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция-сеттер</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineSetter( 'mykey', function( v ) {
	alert( v );
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineSetter" data-title="Метод Matreshka-defineSetter">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-defineSetter(2)">
	<h2>
		<a href="#Matreshka-defineSetter(2)">
			<span class="memberof">Matreshka#</span>defineSetter<wbr>(<span class="args">keySetterPairs</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#Matreshka-defineSetter">Matreshka#defineSetter</a> для установки сеттера &quot;ключ-сеттер&quot;</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keySetterPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект со свойствами ключ-сеттер</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineSetter({
	myKey1: function( v ) { alert( v ); } 
	myKey2: function( v ) { alert( v ); } 
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineSetter(2)" data-title="Метод Matreshka-defineSetter(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-mediate">
	<h2>
		<a href="#Matreshka-mediate">
			<span class="memberof">Matreshka#</span>mediate<wbr>(<span class="args">key, mediator</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Трансформирует значение свойства при его изменении</p></div>
	<div class="description"><p>Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>Ключ или массив ключей или список ключей, разделенных пробелами</p></td>
				</tr>
			 
				<tr>
					<td>
						mediator
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция-посредник (медиатор, mediator), возвращающая новое значение</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.mediate( 'x', function() {
	return String( s );
});
this.x = 1;
alert( typeof this.x ); // "string"</code></pre><h5><p>Список ключей, разделенных пробелами</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate( 'x y', function() {
	return String( s );
});</code></pre><h5><p>Массив ключей</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate( [ 'x', 'y' ], function() {
	return String( s );
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-mediate" data-title="Метод Matreshka-mediate">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-mediate(2)">
	<h2>
		<a href="#Matreshka-mediate(2)">
			<span class="memberof">Matreshka#</span>mediate<wbr>(<span class="args">keyMediatorPairs</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#Matreshka-mediate">Matreshka#mediate</a>, принимающий в качестве аргумента объект &quot;ключ-медиатор&quot;</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyMediatorPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект со свойствами ключ-медиатор</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert( typeof this.x ); // "string"
alert( typeof this.y ); // "number"
alert( typeof this.z ); // "boolean"</code></pre><h5><p>Список ключей, разделенных пробелами</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-mediate(2)" data-title="Метод Matreshka-mediate(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-linkProps">
	<h2>
		<a href="#Matreshka-linkProps">
			<span class="memberof">Matreshka#</span>linkProps<wbr>(<span class="args">keys1, keys2, handler<span class="default-value">=function(v){return v}</span>, setOnInit<span class="default-value">=true</span></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Создает зависимость значения одного свойства от значений других</p></div>
	<div class="description"><p>Метод <code>linkProps</code> создает зависимость значения свойства (первый аргумент) от значений других свойств (второй аргумент). Метод защищен от цикличных ссылок (например a зависит от b, b зависит от c, а c зависит от a) и при ошибке вычислений не блокирует страницу и не бросает исключение о переполнении стека.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys1
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>Свойство (свойства) которое зависит от других свойств</p></td>
				</tr>
			 
				<tr>
					<td>
						keys2
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>От каких свойств зависит искомое свойство (свойства)</p></td>
				</tr>
			 
				<tr>
					<td>
						handler
						
							<span class="signature">optional</span>
						
					</td>
					<td> function(v){return v}
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, возвращающая новое значение</p></td>
				</tr>
			 
				<tr>
					<td>
						setOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Установить ли значение свойства сразу после объявления зависимости</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.linkProps( 'greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert( this.greeting ); // 'Hello, Joe!'</code></pre><h5><p>Сложный пример: вычисление периметра прямоугольника по двум сторонам (и сторон по периметру). Как видите, <code>linkProps</code> можно использовать и для решения математических задач, где каждый член уравнения можно использовать, как неизвестное</p></h5>
<pre class="prettyprint source lang-js"><code>this.a = 3;

this.b = 4;

this.linkProps( 'p', 'a b', function( a, b ) {
	return ( a + b ) * 2;
});

this.linkProps( 'a', 'p b', function( p, b ) {
	return p/2 - b;
});

this.linkProps( 'b', 'p a', function( p, a ) {
	return p/2 - a;
});

alert( this.p ); // 14

this.on( 'change:p', function() {
	alert( 'периметр изменен и равен ' + this.p );
});

this.a = 5; // alerts "периметр изменен и равен 18"</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-linkProps" data-title="Метод Matreshka-linkProps">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-linkProps(2)">
	<h2>
		<a href="#Matreshka-linkProps(2)">
			<span class="memberof">Matreshka#</span>linkProps<wbr>(<span class="args">keys, instancesAndKeys, handler<span class="default-value">=function(v){return v}</span>, setOnInit<span class="default-value">=true</span></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Дополнительная возможность метода <a href="#Matreshka-linkProps">Matreshka#linkProps</a>: зависимость от значений свойств других экземпляров</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>Свойство (свойства) которое зависит от других свойств</p></td>
				</tr>
			 
				<tr>
					<td>
						instancesAndKeys
						
					</td>
					<td> 
					<td>
	<span data-type="array">array</span>
</td>
					<td> <p>Массив, который содержит экземпляры (четные элементы) их ключи (нечетные элементы), от которых зависит искомое свойство (свойства). Такой, возможно, странный синтаксис является следствием ограничений синтаксиса JavaScript.</p></td>
				</tr>
			 
				<tr>
					<td>
						handler
						
							<span class="signature">optional</span>
						
					</td>
					<td> function(v){return v}
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, возвращающая новое значение</p></td>
				</tr>
			 
				<tr>
					<td>
						setOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Установить ли значение свойства сразу после объявления зависимости</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Свойство <code>sum</code> является суммой свойств <code>a</code> и <code>b</code> других экземпляров и вычисляется каждый раз при их изменении</p></h5>
<pre class="prettyprint source lang-js"><code>anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps( 'sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function( a, b ) {
	return a + b;
});

alert( this.sum ); // 5

this.on( 'change:sum', function() {
	alert( 'this.sum равен ' + this.sum );
});

anotherInstance1.a = 5; // "this.sum равен 8"</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-linkProps(2)" data-title="Метод Matreshka-linkProps(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-get">
	<h2>
		<a href="#Matreshka-get">
			<span class="memberof">Matreshka#</span>get<wbr>(<span class="args">key</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает значение свойства</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// то же самое, что и this[ 'myKey' ] или this.myKey
this.get( 'myKey' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-get" data-title="Метод Matreshka-get">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-set">
	<h2>
		<a href="#Matreshka-set">
			<span class="memberof">Matreshka#</span>set<wbr>(<span class="args">key, value, eventOptions</span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента</p></div>
	<div class="description"><p>Список поддерживаемых флагов:</p>
<ul>
<li><code>silent</code> - не вызывать события <code>change</code> и <code>change:KEY</code></li>
<li><code>silentHTML</code> - не менять состояние привязанных элементов</li>
<li><code>force</code> - вызвать события <code>change</code> и <code>change:KEY</code> даже если значение свойства не изменилось</li>
<li><code>forceHTML</code> - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в <code>select</code> были добавлены теги <code>option</code>)</li>
<li><code>skipMediator</code> - предотвращает трансформацию свойства медиатором (см. <a href="#Matreshka-mediate">Matreshka#mediate</a>)</li>
<li><code>skipLinks</code> - предотвращает работу зависимостей, созданных с помощью <a href="#Matreshka-linkProps">Matreshka#linkProps</a></li>
</ul></div>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">change</span> <span class="event">change:KEY</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ</p></td>
				</tr>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Значение</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// то же самое, что и this[ 'myKey' ] = 3
// или this.myKey = 3
// выводит на экран 3
this.set( 'myKey', 3 );</code></pre><h5><p>Используя <code>eventOptions</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// alert не срабатывает
this.set( 'myKey', 4, {
	silent: true
});</code></pre><h5><p>Передача произвольных данных в обработчик</p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.myCustomFlag );
});

// выводит на экран 42
this.set( 'myKey', 4, {
	myCustomFlag: 42
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-set" data-title="Метод Matreshka-set">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-set(2)">
	<h2>
		<a href="#Matreshka-set(2)">
			<span class="memberof">Matreshka#</span>set<wbr>(<span class="args">keyValuePairs, eventOptions</span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#Matreshka-set">Matreshka#set</a> &quot;ключ-значение&quot;</p></div>
	<div class="description"></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyValuePairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект, содаржащий пары ключ-значение</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.set({
	myKey1: 1,
	myKey2: 2
});</code></pre><h5><p>Передача <code>eventOptions</code> в качестве второго аргумента</p></h5>
<pre class="prettyprint source lang-js"><code>this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-set(2)" data-title="Метод Matreshka-set(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-remove">
	<h2>
		<a href="#Matreshka-remove">
			<span class="memberof">Matreshka#</span>remove<wbr>(<span class="args">key, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет свойство</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">delete</span> <span class="event">delete:KEY</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ или ключи, разделенные пробелом</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.remove( 'myKey' );
this.remove( 'myKey1 myKey2' );</code></pre><h5><p>Использование <code>eventOptions</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.remove( 'myKey', {
	silent: true
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-remove" data-title="Метод Matreshka-remove">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-define">
	<h2>
		<a href="#Matreshka-define">
			<span class="memberof">Matreshka#</span>define<wbr>(<span class="args">key, descriptor</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Полностью переписывает дескриптор свойства, используя <code>Object.defineProperty</code></p></div>
	<div class="description"><p>Обратите внимание, <code>Object.defineProperty</code> работает некорректно в Internet Explorer 8. Используйте метод только тогда, когда знаете, что делаете.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ</p></td>
				</tr>
			 
				<tr>
					<td>
						descriptor
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Дескриптор</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Простой пример</p></h5>
<pre class="prettyprint source lang-js"><code>this.define( 'myKey', {
	get: function() { ... }
	set: function() { ... }
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-define" data-title="Метод Matreshka-define">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka-define(2)">
	<h2>
		<a href="#Matreshka-define(2)">
			<span class="memberof">Matreshka#</span>define<wbr>(<span class="args">keyObjectPairs</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис для метода <a href="#Matreshka-define">Matreshka#define</a> &quot;ключ-дескриптор&quot;</p></div>
	<div class="description"><p>Работа метода очень похожа на <code>Object.defineProperties</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyObjectPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект, содаржащий пары ключ-дескриптор</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.define({
	myKey1: {
		get: function() { ... }
		set: function() { ... }
	},
	myKey2: {
		get: function() { ... }
		set: function() { ... }
	}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-define(2)" data-title="Метод Matreshka-define(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka-delay">
	<h2>
		<a href="#Matreshka-delay">
			<span class="memberof">Matreshka#</span>delay<wbr>(<span class="args">f, delay<span class="default-value">=0</span>, thisArg</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Выполняет функцию после заданной задержки</p></div>
	<div class="description"><p>Работа метода очень похожа на <code>setTimaout</code>. В качестве контекста принимается текущий экземпляр или переданный объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						f
						
					</td>
					<td> 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, которая должна быть выполнена после истечения таймера</p></td>
				</tr>
			 
				<tr>
					<td>
						delay
						
							<span class="signature">optional</span>
						
					</td>
					<td> 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> <p>Задержка в миллисекундах</p></td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					<td> 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Контекст</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout">setTimeout на MDN</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'change:x', function() {
	alert( this.x ); // 1 ... 2
});

this.delay( function() {
	this.x = 2;
}, 100 );

this.x = 1;</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-delay" data-title="Метод Matreshka-delay">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

	
<article class="item property" id="Matreshka.version">
	<h2>
		<a href="#Matreshka.version">
			
			<span class="memberof">Matreshka.</span>version</a><span class="type">:
				<span data-type="string">string</span>
			</span>
			
			<!-- <span data-type="string">string</span></span>-->
		
	</h2>
	<div class="summary"><p>Версия Матрешки</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert( Matreshka.version );</code></pre>
	<a class="comments" data-id="Matreshka.version" data-title="Свойство Matreshka.version">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
<article class="item property" id="Matreshka.isXDR">
	<h2>
		<a href="#Matreshka.isXDR">
			
			<span class="memberof">Matreshka.</span>isXDR</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p>Использует ли Матрешка хак с XDomainRequest. Другими словами, является ли текущий браузер Internet Explorer 8</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert( Matreshka.isXDR );</code></pre>
	<a class="comments" data-id="Matreshka.isXDR" data-title="Свойство Matreshka.isXDR">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
<article class="item property" id="Matreshka.defaultBinders">
	<h2>
		<a href="#Matreshka.defaultBinders">
			
			<span class="memberof">Matreshka.</span>defaultBinders</a><span class="type">:
				<span data-type="array">array</span>
			</span>
			
			<!-- <span data-type="array">array</span></span>-->
		
	</h2>
	<div class="summary"><p>Массив функций, возвращающих соответствующий байндер</p></div>
	<div class="description"><p><a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a> - массив функций, которые по очереди проверяют элемент на соответствие заданным в этих функциях правилам и возвращающих байндер (см. <span data-type="binder">binder</span>). Этот массив используется тогда, когда в метод <a href="#Matreshka-bindNode">Matreshka#bindNode</a> не был передан третий аргумент. Подробную инфорацию о привязках смотрите в документации к <a href="#Matreshka-bindNode">Matreshka#bindNode</a>.</p></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#Matreshka.lookForBinder">Matreshka.lookForBinder</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>Кастомный чекбокс</p></h5>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
MK.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).toggleClass( 'checked' );
		}
	}
};

// метод shift добавляет функцию в начало массива Matreshka.defaultBinders
MK.defaultBinders.shift( function( element ) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// если проверка пройдена, возвращаем новый байндер
		return MK.binders.customCheckbox();
	}
});

// ...

this.bindNode( 'myKey', '.custom-checkbox' );</code></pre>
	<a class="comments" data-id="Matreshka.defaultBinders" data-title="Свойство Matreshka.defaultBinders">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
	
<article class="item method " id="Matreshka.extend">
	<h2>
		<a href="#Matreshka.extend">
			<span class="memberof">Matreshka.</span>extend<wbr>(<span class="args">o1, o2</span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Небольшая вспомогательная функция, которая расширяет один объект свойствами другого объекта</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - o1

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						o1
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					 </td>
				</tr>
			 
				<tr>
					<td>
						o2
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var o1 = { a: 3 },
	o2 = { b: 4 };
	
MK.extend( o1, o2 );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.extend" data-title="Метод Matreshka.extend">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Class">
	<h2>
		<a href="#Matreshka.Class">
			<span class="memberof">Matreshka.</span>Class<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Содержит ссылку на глобальную функцию <a href="#Class">Class</a></p></div>
	<div class="description"><p>Такой способ применения функции Class употребляется тогда, когда разрабатываемое приложение использует <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a></p></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.Class({
	method: function() {}
});

// то же самое, что и
Class({
	method: function() {}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Class" data-title="Метод Matreshka.Class">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.$(static)">
	<h2>
		<a href="#Matreshka.$(static)">
			<span class="memberof">Matreshka.</span>$<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Библиотека, используемая Матрешкой (jQuery, Zepto, <a href="#Matreshka.$b">Balalaika</a> или др.)</p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.$( '.my-element' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.$(static)" data-title="Метод Matreshka.$(static)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.$b">
	<h2>
		<a href="#Matreshka.$b">
			<span class="memberof">Matreshka.</span>$b<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Встроенная микро-библиотека <a href="#$b">Балалайка</a></p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.$b( '.my-element' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.$b" data-title="Метод Matreshka.$b">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.useAs$">
	<h2>
		<a href="#Matreshka.useAs$">
			<span class="memberof">Matreshka.</span>useAs$<wbr>(<span class="args">$</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Завтавляет использовать определенную библиотеку для работы с DOM</p></div>
	<div class="description"><p>По умолчанию, Матрешка использует в качестве библиотеки ту, которая находится по ссылке <code>window.$</code>. Если такой переменной нет в глобальном пространстве имен, либо же она не включает в себя наобходимый набор методов, то используется встроенная микро библиотека <a href="#$b">Балалайка</a>.</p>
<p>Метод <a href="#Matreshka.useAs$">Matreshka.useAs$</a> заставляет Матрешку использовать ту библиотеку, которую вы захотите использовать, не смотря на отсутствие таковой в глобальном пространстве имен или по другой причине (например, если используется две разных версии jQuery на странице). Желательно, чтобы метод был запущен перед объявлением какого-либо класса, так как никакой ковертации в объект новой библиотеки не происходит.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						$
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Любая библиотека (jQuery, Zepto, Balalaika или др.)</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>Matreshka.useAs$( jQuery.noConflict() );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.useAs$" data-title="Метод Matreshka.useAs$">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.noop">
	<h2>
		<a href="#Matreshka.noop">
			<span class="memberof">Matreshka.</span>noop<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Пустая функция, которая ничего не делает</p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'x', MK.noop );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.noop" data-title="Метод Matreshka.noop">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.each">
	<h2>
		<a href="#Matreshka.each">
			<span class="memberof">Matreshka.</span>each<wbr>(<span class="args">o, callback, thisArg</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Итерирует любой объект, прогоняя каждое его свойство через функцию <code>callback</code></p></div>
	<div class="description"><p>Этот статичный метод схож с работой <code>Array.prototype.forEach</code>.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						o
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект</p></td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, запускаемая на каждой итерации</p></td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Объект, который используется в качестве <code>this</code> при вызове <code>callback</code></p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var myObject = {
	a: 1,
	b: 2
};
MK.each( myObject, function( value, key ) {
	// ...
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.each" data-title="Метод Matreshka.each">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.debounce">
	<h2>
		<a href="#Matreshka.debounce">
			<span class="memberof">Matreshka.</span>debounce<wbr>(<span class="args">f, duration<span class="default-value">=0</span>, thisArg</span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Запускает функцию лишь однажды после истечения таймера. С каждой попыткой запуска таймер обновляется</p></div>
	<div class="description"><p>Этот метод - реализация микропаттерна <strong>debounce</strong>, который решает проблему многократного вызова обработчика событий за определенный промежуток времени. См. пример и <a href="http://habrahabr.ru/post/60957/">статью на Хабре</a>.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						f
						
					</td>
					<td> 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Оригинальная функция,</p></td>
				</tr>
			 
				<tr>
					<td>
						duration
						
							<span class="signature">optional</span>
						
					</td>
					<td> 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> <p>Задержка</p></td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					<td> 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Контекст, в котором функция должна быть запущена</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var debounced = MK.debounce( function( x ) {
	console.log( x );
}, 10 );

for( var i = 0; i &lt; 100; i++ ) {
	debounced( i );
}

// >>> 100</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.debounce" data-title="Метод Matreshka.debounce">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.lookForBinder">
	<h2>
		<a href="#Matreshka.lookForBinder">
			<span class="memberof">Matreshka.</span>lookForBinder<wbr>(<span class="args">node</span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"></div>
	<div class="description"><p>Возвращает байндер, соответствующий элементу. Если таковой не найден, возвращает <code>undefined</code>. Функция использует <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - properties

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						node
						
					</td>
					 
					<td>
	<span data-type="node">node</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>console.log( Matreshka.lookForBinder( $( 'input[type="text"]' ) ) );

// вернет объект
{
	on: 'keyup paste',
	getValue: function() { return this.value; },
	setValue: function( v ) {
		if( this.value != v ) {
			this.value = v;
		}
	}
}</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.lookForBinder" data-title="Метод Matreshka.lookForBinder">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.randomString">
	<h2>
		<a href="#Matreshka.randomString">
			<span class="memberof">Matreshka.</span>randomString<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="string">string</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Функция, которая возвращает уникальную псевдо-случайную строку</p></div>
	<div class="description"><p>Для генерации строки используются функции <code>new Date().getTime</code> и <code>Math.random()</code>, так что возвращаемая строка уникальна.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="string">string</span>

		 - случайная строка

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var id = MK.ramdomString();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.randomString" data-title="Метод Matreshka.randomString">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

	<article class="item ns" id="Matreshka.binders">
	<h2>
		<a href="#Matreshka.binders">
			<span class="memberof">Matreshka.</span>binders <span data-type="object">object</span>
		</a>
	</h2>
	<div class="summary"></div>
	<div class="description"><p>Пространство имен для байндеров. Этот объект можно расширять собственными свойствами, чтоб не засорять глобальное пространство имен.</p>
<p>Примите во внимание небольшое соглашение: каждое свойство из коллекции <code>Matreshka.binders</code> должно быть оформлено в виде функции, возвращающей байндер.</p></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.binders.myCoolBinder = function( var1, var2 ) {
	return {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... },
		initialize: function() { ... }
	};
};

this.bindNode( 'myKey', '.my-element', MK.binders.myCoolBinder( 'Hello', 'World' ) );</code></pre>
	
	
	<a class="comments" data-id="Matreshka.binders" data-title="Пространство имен Matreshka.binders">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>

<article class="item method " id="Matreshka.binders.innerHTML">
	<h2>
		<a href="#Matreshka.binders.innerHTML">
			<span class="memberof">Matreshka.binders.</span>innerHTML<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, меняющий <code>innerHTML</code> DOM элемента в зависимости от значения свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'myKey', '.my-element', MK.binders.innerHTML() );

// то же самое, что и
this.bindElement( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.innerHTML = v;
	}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.innerHTML" data-title="Метод Matreshka.binders.innerHTML">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.binders.visibility">
	<h2>
		<a href="#Matreshka.binders.visibility">
			<span class="memberof">Matreshka.binders.</span>visibility<wbr>(<span class="args">value<span class="default-value">=true</span></span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, меняющий видимость DOM элемент (используя <code>style.display</code>), в зависимости от значения свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						value
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Если аргумент равен <code>true</code>, то элемент прячется при ложном значении свойства, если равен <code>false</code>, прячется при правдивом значении</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'myKey', '.my-element', MK.binders.visibility(true) );

// то же самое, что и
this.bindElement( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.style.display = v ? '' : 'none';
	}
});</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'myKey', '.my-element', MK.binders.visibility(false) );

// то же самое, что и
this.bindElement( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.style.display = v ? 'none' : '';
	}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.visibility" data-title="Метод Matreshka.binders.visibility">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.binders.className">
	<h2>
		<a href="#Matreshka.binders.className">
			<span class="memberof">Matreshka.binders.</span>className<wbr>(<span class="args">className</span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, который переключает имя класса DOM элемента в зависимости от значения свойства экземпляра класса. Если значение свойства нестрого равно <code>true</code>, имя класса добавляется, в противном случае - убирается. Логику можно изменить, добавив восклицательный знак перед именем класса, и, таким образом, имя класса будет добавляться, когда значение свойства нестрого равно <code>false</code> и наоборот.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						className
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'myKey', '.my-element', MK.binders.className( 'blah' ) );

// то же самое, что и
this.bindElement( 'myKey', '.my-element', {
	setValue: function( v ) {
		$( this ).toggleClass( 'blah', v );
	}
});

this.myKey = true; // добавляет класс 'blah' 

this.myKey = false; // убирает класс 'blah' </code></pre><h5><p>Использование восклицательного знака перед именем класса</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'myKey', '.my-element', MK.binders.className( '!blah' ) );

// то же самое, что и
this.bindElement( 'myKey', '.my-element', {
	setValue: function( v ) {
		$( this ).toggleClass( 'blah', !v );
	}
});

this.myKey = true; // добавляет класс 'blah' 

this.myKey = false; // убирает класс 'blah' </code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.className" data-title="Метод Matreshka.binders.className">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.binders.property">
	<h2>
		<a href="#Matreshka.binders.property">
			<span class="memberof">Matreshka.binders.</span>property<wbr>(<span class="args">property</span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, меняющий свойство DOM элемента на значение свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						property
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'disabled', '.my-button', MK.binders.property( 'disabled' ) );

// то же самое, что и
this.bindElement( 'disabled', '.my-button', {
	setValue: function( v ) {
		this.disabled = v;
	}
});

// устанавливает свойство disabled = true для элемента
this.disabled = true;

// устанавливает свойство disabled = false для элемента
this.disabled = false; </code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.property" data-title="Метод Matreshka.binders.property">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.binders.attribute">
	<h2>
		<a href="#Matreshka.binders.attribute">
			<span class="memberof">Matreshka.binders.</span>attribute<wbr>(<span class="args">attribute</span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, меняющий атрибут DOM элемента на значение свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						attribute
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindElement( 'image', 'img.my-image', MK.binders.attribute( 'src' ) );

// то же самое, что и
this.bindElement( 'image', 'img.my-image', {
	setValue: function( v ) {
		this.setAttribute( 'src', v );
	}
});

this.image = 'http://example.com/cats.jpg';</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.attribute" data-title="Метод Matreshka.binders.attribute">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.binders.input">
	<h2>
		<a href="#Matreshka.binders.input">
			<span class="memberof">Matreshka.binders.</span>input<wbr>(<span class="args">type</span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает двусторонний привязчик, связывающий свойство экземпляра класса с элементом <code>input</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						type
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Тип инпута</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-input', MK.binders.input( 'range' ) );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.input" data-title="Метод Matreshka.binders.input">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.binders.textarea">
	<h2>
		<a href="#Matreshka.binders.textarea">
			<span class="memberof">Matreshka.binders.</span>textarea<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает двусторонний привязчик, связывающий свойство экземпляра с элементом <code>textarea</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-textarea', MK.binders.textarea() );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.textarea" data-title="Метод Matreshka.binders.textarea">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.binders.select">
	<h2>
		<a href="#Matreshka.binders.select">
			<span class="memberof">Matreshka.binders.</span>select<wbr>(<span class="args">multiple<span class="default-value">=false</span></span>)
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает двусторонний привязчик, связывающий свойство экземпляра с элементом <code>select</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						multiple
						
							<span class="signature">optional</span>
						
					</td>
					<td> false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> <p>Является ли селект <code>multiple</code></p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'myKey', '.my-select', MK.binders.select( true ) );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.select" data-title="Метод Matreshka.binders.select">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

</section>

	<section>
	<article class="item class" id="Matreshka.Object">
		<h2>
			<a href="#Matreshka.Object">
				<span class="signature-class">Класс</span> Matreshka.Object
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p><code>Matreshka.Object</code> - класс, который отвечает за данные вида пар ключ-значение. Его задачей является отделение служебных свойств от данных, которые можно передать на сервер или сохранить в локальном хранилище. Класс наследуется от класса <a href="#Matreshka">Matreshka</a> и включает все его свойства и методы.</p>
<p>Представьте себе, что вы создаёте класс, включающий свойства <code>"a"</code>, <code>"b"</code> и <code>"c"</code>. Допустим <code>"a"</code> и <code>"b"</code> - свойства которые должны быть отправлены на сервер, а свойство <code>"c"</code> лишь отвечает за некоторое состояние приложения (например, содержит сумму <code>"a"</code> и <code>"b"</code>). Свойство <code>"c"</code> не нужно серверу. Поэтому нам нужно отделить <strong>свойства отвечающие за данные</strong> от свойств, которые таковыми не являются.</p>
<p>Для того, чтоб объявить такие свойства от остальных, можно воспользоваться методом <a href="#Matreshka.Object-addDataKeys">Matreshka.Object#addDataKeys</a>.</p>
<pre class="prettyprint source lang-js"><code>this.addDataKeys( 'a b' );

this.a = 1;
this.b = 2;
this.c = 3;</code></pre><p>Если вы заранее не знаете, какие свойства являются данными, можно всегда использовать метод <a href="#Matreshka.Object-jset">Matreshka.Object#jset</a>, который не только объявляет свойства, отвечающие за данные, но и сразу устанавливает значения.</p>
<pre class="prettyprint source lang-js"><code>this.jset({
    a: 1,
    b: 2
});

this.c = 3;</code></pre><p>После того, как приложение "узнало" о том, что является данными, экземпляр <a href="#Matreshka.Object">Matreshka.Object</a> можно сконвертировать в обычный объект методом <a href="#Matreshka.Object-toJSON">Matreshka.Object#toJSON</a> и передать на сервер или сохранить в локальной БД (например, в <code>localStorage</code>).</p>
<pre class="prettyprint source lang-js"><code>// вернет объект { a: 1, b: 2 }
this.toJSON();</code></pre><p>При изменении свойств, отвечающих за данные генерируется событие <code>modify</code></p>
<pre class="prettyprint source lang-js"><code>this.on( 'modify', function() {
    alert( 'Object is modified' );
});</code></pre>
		</div>
		
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						data
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Данные, входящие в новый экземпляр</p></td>
				</tr>
			
		</tbody>
	</table>

		

		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Object;</code></pre><h5><p>Создание экземпляра с двумя заданными свойствами</p></h5>
<pre class="prettyprint source lang-js"><code>// то же самое, что и new MK.Object().jset({ a: 1, b: 2 });
new MK.Object({ a: 1, b: 2 });</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': MK.Object,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Наследование, используя синтаксис ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends MK.Object {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre><h5><p>Перебор данных, используя цикл for..of из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({ a: 1, b: 2 });
for(let item of mkObject) {
	console.log( item ); // 1 .. 2
}</code></pre>
		<a class="comments" data-id="Matreshka.Object" data-title="Класс Matreshka.Object">Задать вопрос<i></i></a>
<div class="comments-container"></div>
	</article>
	
<article class="item property" id="Matreshka.Object-isMKObject">
	<h2>
		<a href="#Matreshka.Object-isMKObject">
			
			<span class="memberof">Matreshka.Object#</span>isMKObject</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p>Свойство <code>isMKObject</code> всегда равно <code>true</code>. Оно используется для проверки, является ли объект экземпляром <a href="#Matreshka.Object">Matreshka.Object</a>.</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert( object.isMKObject );</code></pre>
	<a class="comments" data-id="Matreshka.Object-isMKObject" data-title="Свойство Matreshka.Object-isMKObject">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
	
<article class="item method " id="Matreshka.Object-keys">
	<h2>
		<a href="#Matreshka.Object-keys">
			<span class="memberof">Matreshka.Object#</span>keys<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает массив ключей, отвечающих за данные</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		 - keys

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var keys = this.keys();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-keys" data-title="Метод Matreshka.Object-keys">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-on">
	<h2>
		<a href="#Matreshka.Object-on">
			<span class="memberof">Matreshka.Object#</span>on<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает так же, как и <a href="#Matreshka-on">Matreshka#on</a>, но дополнительно позволяет динамически навешивать обработчики на свойства, отвечающие за данные без прямого указания имени свойства</p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object();

mkObject.on( '@something', function() {
	alert( 'something happens' )
});

mkObject.jset( 'x', new MK );

mkObject.x.trigger( 'something' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-on" data-title="Метод Matreshka.Object-on">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-hasOwnProperty">
	<h2>
		<a href="#Matreshka.Object-hasOwnProperty">
			<span class="memberof">Matreshka.Object#</span>hasOwnProperty<wbr>(<span class="args">key</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Проверяет есть ли в экземпляре свойство, отвечающее за данные, с заданным ключем</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.hasOwnProperty( 'a' ); // true

mkObject.hasOwnProperty( 'b' ); // true

mkObject.hasOwnProperty( 'c' ); // false</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-hasOwnProperty" data-title="Метод Matreshka.Object-hasOwnProperty">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-toObject">
	<h2>
		<a href="#Matreshka.Object-toObject">
			<span class="memberof">Matreshka.Object#</span>toObject<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр <a href="#Matreshka.Object">Matreshka.Object</a> в обычный объект, но не конвертирует входящие в него свойства</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5><p>Basic usage</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toObject(); // возвращает { a: 1, b: 2 }</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toObject" data-title="Метод Matreshka.Object-toObject">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-toNative">
	<h2>
		<a href="#Matreshka.Object-toNative">
			<span class="memberof">Matreshka.Object#</span>toNative<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#Matreshka.Object-toObject">Matreshka.Object#toObject</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5><p>Usage</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toNative(); // возвращает { a: 1, b: 2 }</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toNative" data-title="Метод Matreshka.Object-toNative">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-toJSON">
	<h2>
		<a href="#Matreshka.Object-toJSON">
			<span class="memberof">Matreshka.Object#</span>toJSON<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр и внутренние свойства <a href="#Matreshka.Object">Matreshka.Object</a> обычный объект</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2,
	c: new MK.Object({
		d: 3,
		e: 4
	})
});

// возвращает { a: 1, b: 2, c: { d: 3, e: 4 } }
mkObject.toJSON();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toJSON" data-title="Метод Matreshka.Object-toJSON">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-keyOf">
	<h2>
		<a href="#Matreshka.Object-keyOf">
			<span class="memberof">Matreshka.Object#</span>keyOf<wbr>(<span class="args">value</span>)
		</a> <span class="returns">→ 
	<span data-type="string">string</span>

	<span data-type="null">null</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Ищет заданное значение свойства среди свойств, отвечающих за данные и возвращает ключ, если такое значение найдено  (аналог <code>Array.prototype.indexOf</code>)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="string">string</span>

	<span data-type="null">null</span>

		

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>значение любого типа, которое следует найти среди данных</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.keyOf( 1 ); // 'a'

mkObject.keyOf( 2 ); // 'b'

mkObject.keyOf( 3 ); // null</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-keyOf" data-title="Метод Matreshka.Object-keyOf">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-jset">
	<h2>
		<a href="#Matreshka.Object-jset">
			<span class="memberof">Matreshka.Object#</span>jset<wbr>(<span class="args">key, value, evtOpts</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает свойство и добавляет ключ в список ключей, отвечающих за данные</p></div>
	<div class="description"><p>Этот метод делает две вещи:</p>
<p>1. Устанавливает заданное значение заданному свойству.</p>
<p>2. Добавляет ключ свойства в список данных, что далет свойство доступным для использования в методах <a href="#Matreshka.Object-each">Matreshka.Object#each</a>, <a href="#Matreshka.Object-keys">Matreshka.Object#keys</a>, <a href="#Matreshka.Object-toObject">Matreshka.Object#toObject</a> и <a href="#Matreshka.Object-toJSON">Matreshka.Object#toJSON</a>).</p>
<p>В остальном, метод работает так же, как и <a href="#Matreshka-set">Matreshka#set</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">change</span> <span class="event">change:KEY</span> <span class="event">modify</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ</p></td>
				</tr>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Значение</p></td>
				</tr>
			 
				<tr>
					<td>
						evtOpts
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-set">Matreshka#set</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset( 'a', 1 ).jset( 'b', 2 );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset( 'a', 1 ).jset( 'b', 2 );

// присваиваем свойству 'c' тройку,
// но не добавляем ключ в список ключей, отвечающих за данные
this.set( 'c', 3 );

this.each( function( value, key ) {
	console.log( key, value ); 
});

// выводит 'a' 1 и 'b' 2

console.log( this.keys() ); // выводит [ 'a', 'b' ]

console.log( this.toJSON() ); // выводит { a: 1, b: 2 }</code></pre><h5><p>После использования  метода <a href="#Matreshka.Object-jset">Matreshka.Object#jset</a> со свойством можно работать, как с обычным свойством</p></h5>
<pre class="prettyprint source lang-js"><code>this.jset( 'a', 1 ).jset( 'b', 2 );
this.set( 'a', 3 ); 
this.b = 4;</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-jset" data-title="Метод Matreshka.Object-jset">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-jset(2)">
	<h2>
		<a href="#Matreshka.Object-jset(2)">
			<span class="memberof">Matreshka.Object#</span>jset<wbr>(<span class="args">keyValuePairs, evtOpts</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#Matreshka.Object-jset">Matreshka.Object#jset</a>, который использует объект ключ-значение для установки нескольких свойств сразу</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyValuePairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Объект ключ-значение</p></td>
				</tr>
			 
				<tr>
					<td>
						evtOpts
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset({
	a: 1,
	b: 2
});</code></pre><h5><p>Использование объекта события</p></h5>
<pre class="prettyprint source lang-js"><code>this.jset({
	a: 1,
	b: 2
}, { silent: true });</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-jset(2)" data-title="Метод Matreshka.Object-jset(2)">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-remove">
	<h2>
		<a href="#Matreshka.Object-remove">
			<span class="memberof">Matreshka.Object#</span>remove<wbr>(<span class="args">key, evtOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет свойство из экземпляра класса <a href="#Matreshka.Object">Matreshka.Object</a> и из списка ключей, отвечающих за данные</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">delete</span> <span class="event">delete:KEY</span> <span class="event">modify</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> <p>Ключ (или список ключей, разделенных пробелами)</p></td>
				</tr>
			 
				<tr>
					<td>
						evtOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-remove">Matreshka#remove</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.remove( 'myKey' );
this.remove( 'myKey1 myKey2' );</code></pre><h5><p>Использование объекта события</p></h5>
<pre class="prettyprint source lang-js"><code>this.remove( 'myKey', { silent: true } );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-remove" data-title="Метод Matreshka.Object-remove">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-addDataKeys">
	<h2>
		<a href="#Matreshka.Object-addDataKeys">
			<span class="memberof">Matreshka.Object#</span>addDataKeys<wbr>(<span class="args">keys</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет ключи в список ключей, отвечающих за данные</p></div>
	<div class="description"><p>Этот метод применяется тогда, когда нужно объявить ключи, отвечающие за данные, но значения соответствующих свойств еще не известны.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>Ключ, или ключи разделенные пробелами, или массив ключей</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys( 'a b' );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys( [ 'a', 'b' ] );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys( 'a', 'b' );</code></pre><h5><p>Пример с <a href="#Matreshka.Object-each">Matreshka.Object#each</a></p></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys( 'a b' );

this.each( function( value, key ) {
	console.log( key, value );
});
// выводит 'a' undefined and 'b' undefined</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-addDataKeys" data-title="Метод Matreshka.Object-addDataKeys">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-removeDataKeys">
	<h2>
		<a href="#Matreshka.Object-removeDataKeys">
			<span class="memberof">Matreshka.Object#</span>removeDataKeys<wbr>(<span class="args">keys</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет ключи из списка ключей, отвечающих за данные (но не удаляет свойство)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> <p>Ключ или ключи разделенные пробелами или массив ключей</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys( 'a b' );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys( [ 'a', 'b' ] );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys( 'a', 'b' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-removeDataKeys" data-title="Метод Matreshka.Object-removeDataKeys">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Object-each">
	<h2>
		<a href="#Matreshka.Object-each">
			<span class="memberof">Matreshka.Object#</span>each<wbr>(<span class="args">callback, thisArg</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Перебирает свойства, отвечающие за данные</p></div>
	<div class="description"><p>Метод очень похож на <code>Array.prototype.forEach</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, которая вызывается на каждой итерации</p></td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Контекст функции</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.each( function( value, key ) {
	... 
}, this );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this
	.jset({ a: 1, b: 2 })
	.addDataKeys( 'c' )
	.each( function( value, key ) {
		console.log( key, value );
	}, this );
; 
// >>> a 1, b 2, c undefined</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-each" data-title="Метод Matreshka.Object-each">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

	
	
	
</section>

	<section>
	<article class="item class" id="Matreshka.Array">
		<h2>
			<a href="#Matreshka.Array">
				<span class="signature-class">Класс</span> Matreshka.Array
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p>Класс <code>Matreshka.Array</code> служит коллекцией во фреймворке Метрешка. Он наследуется от класса <a href="#Matreshka">Matreshka</a>, получая все без исключения возможности родителя. Кроме этого, <code>Matreshka.Array</code> имеет все методы, которые есть у обычного массива.</p>
<h4>Все методы, позаимствованные у встроенного Array работают аналогично их оригиналам</h4><p>Программист, знакомый с методами нативного <code>Array</code> сразу может понять, каким методом можно добавить элемент (<code>push</code>, <code>unshift</code>, <code>splice</code>), каким удалить (<code>pop</code>, <code>shift</code>, <code>splice</code>), каким отсортировать (<code>sort</code>, <code>reverse</code>) и т. д. Исключением из этого правила является метод <code>forEach</code>, который в оригинальном виде всегда возвращает <code>undefined</code>, а, в случае с <a href="#Matreshka.Array">Matreshka.Array</a> возвращает "себя" для возможности цепочечного вызова. По причине того, что методы работают точно так же, как и оригинальные, они не приведены в этой документации по отдельности, а выведены в раздел <a href="#Matreshka.Array-METHOD">Matreshka.Array#METHOD</a>.</p>
<pre class="prettyprint source lang-js"><code>this.push( 1, 2, 3 );
this.pop();</code></pre><h4>Все методы, позаимствованные у встроенного Array, которые модифицируют массив могут быть вызваны с передачей объекта события</h4><p>Для этого используется синтаксис <code>метод_</code>, где нижнее подчеркивание в конце имени метода означает, что последним аргументом является объект события. Такие методы не приведены в этой документации, так как требуется запомнить только их синтаксис. См.  <a href="#Matreshka.Array-METHOD_">Matreshka.Array#METHOD_</a>.</p>
<pre class="prettyprint source lang-js"><code>this.push_( 1, 2, 3, {
    silent: true
});
this.pop_({
    silent: true
});</code></pre><h4>Разработчик имеет возможность отлавливать любые модификации данных</h4><p><strong>При использовании методов, позаимствованных у встроенного <code>Array</code> генерируются события с соответствующим именем.</strong> Вызывая метод <code>push</code>, генерируется событие <code>push</code> вызывая метод <code>pull</code> генерируется событие <code>pull</code>, вызывая метод <code>sort</code>, генерируется событие <code>sort</code> и так далее... Список аргументов можно получить, обратясь к свойству <code>args</code>.</p>
<pre class="prettyprint source lang-js"><code>this.on( 'push', function( evt ) {
    console.log( evt.args ); // [1,2,3]
});

this.push( 1, 2, 3 );</code></pre><p><strong>При добавлении элементов генерируются события <code>add</code> и <code>addone</code>.</strong> Первое генерируется один раз на добавление (например, вы добавили несколько элементов с помощью <code>push</code>, событие вызвалось только один раз), второе генерируется один раз на каждый добавленный элемент. При срабатывании события <code>add</code>, в объект события (свойство <code>added</code>) передается массив добавленных элементов, а при срабатывании <code>addone</code>, в него же передаётся каждый отдельный добавленный элемент.</p>
<pre class="prettyprint source lang-js"><code>this.on( 'add', function( evt ) {
    console.log( evt.added ); // [1,2,3]
});

this.push( 1, 2, 3 );</code></pre><pre class="prettyprint source lang-js"><code>// обработчик запустится трижды,
// так как в массив добавили три новых элемента
this.on( 'addone', function( evt ) {
    console.log( evt.added ); // 1 ... 2 ... 3
});

this.push( 1, 2, 3 );</code></pre><p><strong>При удалении элементов действует та же логика</strong>: <code>remove</code> срабатывает один раз, даже если удалено несколько элементов, а событие <code>removeone</code> срабатывает для каждого удаленного элемента индивидуально. Удаленные элементы содержатся в свойстве <code>removed</code> объекта события.</p>
<pre class="prettyprint source lang-js"><code>this.push( 1, 2, 3, 4, 5 );

this.on( 'remove', function( evt ) {
    console.log( evt.removed ); // [2,3,4]
});

this.splice( 1, 3 );</code></pre><pre class="prettyprint source lang-js"><code>this.push( 1, 2, 3, 4, 5 );

// обработчик запустится трижды,
// так как в массив добавили три новых элемента
this.on( 'removeone', function( evt ) {
    console.log( evt.added ); // 2 ... 3 ... 4
});

this.splice( 1, 3 );</code></pre><p><strong>При каждой модификации массива генерируется событие <code>modify</code></strong>, позволяя отловить все без исключения изменения в массиве (добавление, удаление, пересортировку).</p>
<pre class="prettyprint source lang-js"><code>this.on( 'modify', function( evt ) {
    ...
});</code></pre><p><strong><code>length</code> - это обычное свойство</strong> которое можно связывать с HTML элементом или отлавливать изменения с помощью события <code>change:length</code>.</p>
<blockquote>
<p>Например, при добавлении трех элементов с помощью метода <code>push</code> с тремя аргументами, генерируются следующие события: <code>push</code>, <code>add</code>, <code>addone</code> (трижды), <code>modify</code>, <code>change:length</code>.</p>
</blockquote>
<h4>Model</h4><p>Свойство <a href="#Matreshka.Array-Model">Matreshka.Array#Model</a> определяет класс элементов, которые будет содержать коллекция. Его поведение очень напоминает поведение свойства <code>model</code> из <code>Backbone.Collection</code>. Рекомендуется наследовать <code>Model</code> от класса <a href="#Matreshka.Object">Matreshka.Object</a> или <a href="#Matreshka.Array">Matreshka.Array</a> (на случай, если тебуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом <a href="#Matreshka.Array-toJSON">Matreshka.Array#toJSON</a>.</p>
<pre class="prettyprint source lang-js"><code>// определяем Модель
var MyModel = Class({
    // она наследуется от MK.Object
    'extends': MK.Object,
    constructor: function( data ) {
        // устанавливаем переданные свойства методом jset
        this.jset( data );
    }
});

// опеределяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray;

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();</code></pre><h4>Автоматический рендеринг</h4><p><code>Matreshka.Array</code> умеет автоматически отрисовывать элементы на странице <strong>при любых модификациях</strong> массива. Для этого применяется свойство <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>. Программисту больше не нужно заботиться о перестройке HTML дерева, <code>Matreshka.Array</code> делает это за него. Ниже пример использования автоматического рендеринга списка.</p>
<pre class="prettyprint source lang-html"><code>&lt;ul class="my-list">&lt;/ul></code></pre><pre class="prettyprint source lang-js"><code>var MyModel = MK.Class({
    'extends': MK.Object,
    constructor: function( data ) {
        this.jset( data );

        // ждем события 'render'
        this.on( 'render', function() {
            // и привязываем свойство 'value'
            // к новосозданному HTML элементу &lt;li>
            this.bindNode( 'value', ':sandbox', MK.binders.innerHTML() );
        });
    }
});

var MyArray = MK.Class({
    'extends': MK.Array,
    Model: MyModel,
    // определяем рендерер для каждого элемента коллекции
    itemRenderer: '&lt;li>',
    constructor: function() {
        // создаём песочницу
        this.bindNode( 'sandbox', '.my-list' );
    }
});

var myArray = new MyArray;
myArray.push({
    value: 'Hello'
}, {
    value: 'World'
});</code></pre><p>За подробностями обратитесь к документации <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>.</p>
		</div>
		
		
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
		<li><a href="#Matreshka.Array-Model">Matreshka.Array#Model</a>
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array;</code></pre><h5><p>Создание экземпляра с указанием длины</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array( 42 );</code></pre><h5><p>Передача элементов при создании</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array( 'Hi', { a: 'b' } );</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': MK.Array,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Наследование, используя синтаксис ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends MK.Array {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre><h5><p>Перебор данных, используя цикл for..of из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = new MK.Array( 1, 2, 3 );
for(let item of mkArray) {
	console.log( item ); // 1 .. 2 .. 3
}</code></pre><h5><p>Прослушивание событий</p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'modify', function( evt ) {
	alert( '1) Вызван метод ' + evt.method );
});

this.on( 'shift', function( evt ) {
	alert( '2) Вызван метод ' + evt.method );
});

this.push( 1 ); // 1) Вызван метод push

this.shift(); // 1) Вызван метод shift, 2) Вызван метод shift</code></pre><h5><p>Передача объекта события во встроенный метод <code>Array</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'modify', function( evt ) {
	alert( evt.customData );
});

this.push_( 1, {
	silent: true // событие не генерируется
}); 

this.shift_({
	customData: 42 // 42
}); </code></pre>
		<a class="comments" data-id="Matreshka.Array" data-title="Класс Matreshka.Array">Задать вопрос<i></i></a>
<div class="comments-container"></div>
	</article>
	
<article class="item property" id="Matreshka.Array-isMKArray">
	<h2>
		<a href="#Matreshka.Array-isMKArray">
			
			<span class="memberof">Matreshka.Array#</span>isMKArray</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p><code>isMKArray</code> всегда равен <code>true</code>. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса <a href="#Matreshka.Array">Matreshka.Array</a></p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(object.isMKArray);</code></pre>
	<a class="comments" data-id="Matreshka.Array-isMKArray" data-title="Свойство Matreshka.Array-isMKArray">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
<article class="item property" id="Matreshka.Array-useBindingsParser">
	<h2>
		<a href="#Matreshka.Array-useBindingsParser">
			
			<span class="memberof">Matreshka.Array#</span>useBindingsParser</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p>Свойство включает экспериментальный парсер, если присвоить ему <code>true</code></p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: true,
	itemRenderer: '&lt;li>'
});</code></pre>
	<a class="comments" data-id="Matreshka.Array-useBindingsParser" data-title="Свойство Matreshka.Array-useBindingsParser">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
<article class="item property" id="Matreshka.Array-renderIfPossible">
	<h2>
		<a href="#Matreshka.Array-renderIfPossible">
			
			<span class="memberof">Matreshka.Array#</span>renderIfPossible</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>
			
			<!-- <span data-type="boolean">boolean</span></span>-->
		
	</h2>
	<div class="summary"><p>Свойство <code>renderIfPossible</code> отменяет рендеринг массива</p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
	itemRenderer: '&lt;li>'
    renderIfPossible: false,
    // ...
});</code></pre>
	<a class="comments" data-id="Matreshka.Array-renderIfPossible" data-title="Свойство Matreshka.Array-renderIfPossible">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article>
<article class="item property" id="Matreshka.Array-itemRenderer">
	<h2>
		<a href="#Matreshka.Array-itemRenderer">
			
			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>itemRenderer</a><span class="type">:
				<span data-type="string">string</span> <span data-type="function">function</span>
			</span>
			
			<!-- <span data-type="string">string</span></span>-->
		<i class="important" title="Важно"></i>
	</h2>
	<div class="summary"><p>HTML строка, селектор или функция, отвечающая за отрисовку элементов массива на странице</p></div>
	<div class="description"><p>Свойство <code>itemRenderer</code> - это переопределяемое свойство, которое позволяет рендерить элементы массива без участия программиста. При вставке нового элемента в массив, автоматически создается HTML узел. Этот узел становится песочницей (см. <a href="#Matreshka-bindNode">Matreshka#bindNode</a>) для вставленного элемента и встраивается в HTML контейнер, определенный в массиве.</p>
<h4>Куда вставляется созданный элемент?</h4><p>Для того, чтобы определить HTML контейнер в который будут вставлятьсв отрисованные HTML узлы, нужно определить <strong>контейнер</strong>. Для этого следует объявить HTML песочницу для массива либо связать специальный ключ <code>container</code> с HTML контейнером. Подробнее о привязках и песочнице см. <a href="#Matreshka-bindNode">Matreshka#bindNode</a>.
Пример использования песочницы в качестве контейнера:</p>
<pre class="prettyprint source lang-html"><code>&lt;ul class="my-list">&lt;/ul></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: '&lt;li>',
    Model: MyModel,
    constructor: function() {
        // определяем песочницу
        this.bindNode( 'sandbox', '.my-list' );
    }
});</code></pre><p>Теперь все новосозданные узлы <code>&lt;li&gt;</code> попадут в узел <code>.my-list</code></p>
<p>Если вы не хотите вставлять HTML узлы непосредственно в песочницу, можете связать ключ <code>container</code> с необходимым элементом. Такая логика нужна в том случае, если песочница не ограничена одними лишь элементами коллекции и включает в себя другие HTML узлы.</p>
<pre class="prettyprint source lang-html"><code>&lt;div class="my-widget">
    &lt;h1>This is my awesome list&lt;/h1>
    &lt;ul class="my-list">&lt;/ul>
&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: '&lt;li>',
    Model: MyModel,
    constructor: function() {
        // определяем песочницу
        this.bindNode( 'sandbox', '.my-widget' );
        // определяем контейнер для HTML элементов
        this.bindNode( 'container', '.my-list' );
    }
});</code></pre><p>В примере выше HTML узлы будут вставляться в <code>.my-list</code> вместо <code>.my-widget</code>.</p>
<p>Свойство <code>itemRenderer</code> поддерживает несколько вариантов определения, но все они должны содержать или возвращать единственный HTML узел.</p>
<h4>HTML строка в качестве значения свойства</h4><p>Как видно из примера выше, <code>itemRenderer</code> может быть определен, как HTML строка.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;div class="my-div">Be cool&lt;/div>',
    constructor: function() { ... }
});</code></pre><h4>Селектор в качестве значения свойства</h4><p>На случай, если вы выносите шаблоны для элементов на HTML страницу, <code>itemRenderer</code> поддерживает селектор в качестве значения. В этом случае, <a href="#Matreshka.Array">Matreshka.Array</a> будет искать HTML элемент в DOM дереве и извлечет <code>innerHTML</code> найденого элемента. В случае, если элемент не найден, бросается исключение. HTML текст от селектора отличается наличием  символа <code>&lt;</code> в строке.</p>
<pre class="prettyprint source lang-html"><code>&lt;script type="text/html" id="be-cool-template">
    &lt;div class="my-div">Be cool&lt;/div>
&lt;/script></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
    itemRenderer: '#be-cool-template',
    constructor: function() { ... }
});</code></pre><h4>Функция в качестве значения свойства</h4><p>Использование функции в качестве значения свойства <code>itemRenderer</code> даёт дополнительную гибкость кода, если есть нужда динамически генерировать элемент для рендеринга. Функция может возвращать:</p>
<p><strong>HTML строку</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: function() {
        return '&lt;div class="my-div">Be cool&lt;/div>';
    },
    constructor: function() { ... }
});</code></pre><p><strong>Селектор</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: function() {
        return '#be-cool-template';
    },
    constructor: function() { ... }
});</code></pre><p><strong>DOM узел</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: function() {
        return document.createElement( 'div' );
    }
});</code></pre><h4>Переопределение родительского рендерера свойством <code>render</code></h4><p>Иногда удобно объявлять рендерер внутри класса <a href="#Matreshka.Array-Model">Matreshka.Array#Model</a>, как это делает <code>Backbone</code>. Свойство <code>renderer</code> переопределяет значение <code>itemRenderer</code>, если оно задано для дочернего элемента коллекции.</p>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    renderer: '&lt;div class="my-div">Be cool&lt;/div>',
    constructor: function( data ) { ... }
});

var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;frameset>Not cool&lt;/frameset>',
    constructor: function() { ... }
});</code></pre><p>В этом случае, можно вовсе не указывать <code>itemRenderer</code>, так как <code>render</code> дочернего элемента перенимает все его возможности. Синтаксис остаётся такими же: можно использовать HTML, селектор или функцию.</p>
<h4>Событие <code>render</code></h4><p>После того, как элемент вставлен в массив, а его HTML узел уже создан, но еще не вставлен в контейнер, генерируется событие <code>render</code> на вставленном элементе. После его генерации можно объявить привязки свойств к HTML узлам, содержащимся внутри вставленного.</p>
<pre class="prettyprint source lang-html"><code>&lt;form class="my-form">&lt;/form></code></pre><pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    constructor: function( data ) {
        this.set( data );

        // ждем генерации события
        this.on( 'render', function() {
            this.bindNode( 'isChecked', ':sandbox .my-checkbox' );
            this.bindNode( 'text', ':sandbox .text', MK.binders.innerHTML() );
        });
    }
});

var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;label>\
        &lt;input type="checkbox" class="my-checkbox">\
        &lt;span class="text">&lt;/span>\
    &lt;/label>',
    constructor: function() {
        this.bindNode( 'sandbox', '.my-form' );
        this.push({
            isChecked: true,
            text: 'Be cool'
        }, {
            isChecked: false,
            text: 'Produce shitcode'
        });
    }
});

var app = new MyArray();</code></pre><p>Код выше создаст такое HTML дерево:</p>
<pre class="prettyprint source lang-html"><code>&lt;form class="my-form">
    &lt;label>
        &lt;input type="checkbox" class="my-checkbox">
        &lt;span class="text">Be cool&lt;/span>
    &lt;/label>
    &lt;label>
        &lt;input type="checkbox" class="my-checkbox">
        &lt;span class="text">Produce shitcode&lt;/span>
    &lt;/label>
&lt;/form></code></pre><p>И свяжет чекбоксы с соответствующими свойствaми <code>isChecked</code> и <code>text</code>. <a href="http://jsbin.com/zetuya/1/" target="_blank">Живой пример</a></p>
<p>Не забывайте, что в Матрешке реализована возможность отлова всплывающих событий. Т. е. сам массив может отловить событие рендеринга элемента, используя имя события <code>@render</code> (см. документацию к <span data-type="eventNames">eventNames</span>).</p>
<pre class="prettyprint source lang-js"><code>this.on( '@render', function( evt ) {
    alert( 'Child element is rendered' );
});</code></pre><blockquote>
<p>Отрисованный HTML узел становится песочницей для вставленного элемента, позволяя использовать селектор <code>:sandbox</code> и другие возможности после рендеринга. Если элемент входит сразу в несколько коллекций, установите ему свойство <code>bindRenderedAsSandbox: false</code>, чтобы отменить это поведение.</p>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    bindRenderedAsSandbox: false
    // ...
});</code></pre></blockquote>
<h4>Экспериментальный шаблонизатор</h4><p>Взглянув на примеры использования <a href="#Matreshka.Array">Matreshka.Array</a> и <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> можно обратить внимание на то, что вся логика, отвечающая за двустороннюю и одностороннюю привязку данных заключена в JavaScript коде. Это одно из главных преимуществ Матрешки. Но когда разрабатываешь очень простую коллекцию, не включающую в себя сложную логику, массу привязок и пр. хотелось бы иметь более краткий вариант объявления привязок. Для этого, в <code>itemRenderer</code> может быть передан шаблон, включающий привязки. Для того, чтоб включить шаблонизацию, используйте ключ <a href="#Matreshka.Array-useBindingsParser">Matreshka.Array#useBindingsParser</a>, установленный, как <code>true</code>.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    useBindingsParser: true,
    Model: MK.Object,
    itemRenderer: '&lt;label>\
        &lt;input type="checkbox" checked="&#123;{isChecked}}">&#123;{text}}\
    &lt;/label>',
    constructor: function() {
        this.bindNode( 'sandbox', '.my-form' );
        this.push({
            isChecked: true,
            text: 'Be cool'
        }, {
            isChecked: false,
            text: 'Produce shitcode'
        });
    }
});

var app = new MyArray();</code></pre><p>Пример выше полностью повторяет предыдущий, но не требует создания отдельного класса для Модели, так как нам не требуется отлавливать событие <code>render</code> и объявлять привязки вручную. <a href="http://jsbin.com/wabiyi/1/" target="_blank">Живой пример</a></p>
<p>Такой подход выглядит очень привлекательно, но он имеет несколько особенностей из-за которых рекомендуется избегать экспериментальный шаблонизатор:</p>
<ul>
<li>Шаблонизатор - это экспериментальная возможность Матрешки. Он может рыботать нестабильно в некоторых, неучтенных случаях.</li>
<li>Скорость кода с шаблонизатором ниже, чем без него. Это происходит из-за того, что анализ строки, перебор ключей в цикле (при использовании нескольких ключей в одном атрибуте), замена подсток регулярным выражением и пр. требуют больше ресурсов.</li>
<li>Дополнительного синтаксиса не предусмотрено. Условия и циклы должны быть объявлены в JavaScript коде, а обращение к дочернему объекту не учтено (т. е. такой код не сработает: &#123;{a.b}})</li>
</ul>
<p>В целом, используйте шаблонизатор только тогда, когда разрабатываемое приложение не велико и не требовательно к производительности.</p>
<h4>Отмена рендеринга</h4><p>Как видно выше, если у дочернего элемента задано свойство <code>render</code>, <code>Matreshka.Array</code> попробует его отрисовать. Для того, чтоб полностью отменить рендеринг для массива, присвойте свойству <code>renderIfPossible: false</code>.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    renderIfPossible: false,
    // ...
});</code></pre></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#Matreshka.Array-Model">Matreshka.Array#Model</a>
	
</ul>


	  

	<a class="comments" data-id="Matreshka.Array-itemRenderer" data-title="Свойство Matreshka.Array-itemRenderer">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
	
<article class="item method " id="Matreshka.Array-Model">
	<h2>
		<a href="#Matreshka.Array-Model">
			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>Model<wbr>(<span class="args">data, mkArray</span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство определяет класс элементов, которые будет содержать коллекция</p></div>
	<div class="description"><p>При каждом добавлении элементов в массив, встроенный обработчик проверяет, является ли добавленный элемент экземпляром <code>Model</code> и конвертирует его в таковой, если проверка не пройдена. Это поведение очень напоминает поведение свойства <code>model</code> из <code>Backbone.Collection</code>. Рекомендуется наследовать <code>Model</code> от класса <a href="#Matreshka.Object">Matreshka.Object</a> или <a href="#Matreshka.Array">Matreshka.Array</a> (на случай, если тебуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом <a href="#Matreshka.Array-toJSON">Matreshka.Array#toJSON</a>.</p>
<p>Для более гибкого контроля класса элементов (например, если для одних элементов нужно использовать одну Модель, а для других - другую), используйте <a href="#Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a>.</p></div>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						data
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Данные, переданные в конструктор</p></td>
				</tr>
			 
				<tr>
					<td>
						mkArray
						
					</td>
					 
					<td>
	<span data-type="matreshkaArray">matreshkaArray</span>
</td>
					<td> <p>Массив, в который добавили элемент</p></td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a>
	
		<li><a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// определяем Модель
var MyModel = Class({
	// она наследуется от MK.Object
	'extends': MK.Object,
	constructor: function( data ) {
		// устанавливаем переданные свойства методом jset
		this.jset( data );
		this.doSomething();
	},
	doSomething: function() { ... }
});

// опеределяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray;

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();</code></pre><h5><p><code>Model</code> и ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyArray extends MK.Array {
	get Model() {
		return MyModel;
	}
}</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-Model" data-title="Метод Matreshka.Array-Model">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-mediateItem">
	<h2>
		<a href="#Matreshka.Array-mediateItem">
			<span class="memberof">Matreshka.Array#</span>mediateItem<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Трансформирует значение элемента при вставке</p></div>
	<div class="description"><p>Этот метод служит для того, чтоб установить типизацию для вставляемых элементов. Обратите внимание, метод переопределяет свойство <a href="#Matreshka.Array-Model">Matreshka.Array#Model</a>.</p></div>
	
	
	
	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-Model">Matreshka.Array#Model</a>
	
		<li><a href="#Matreshka-mediate">Matreshka#mediate</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// все элементы массива - числа
this.mediateItem( Number );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.push( 1, 2, 3, 4, 5 );

// все элементы массива - строки
this.mediateItem( function( value ) {
	return String( value );
});

this.push( 6, 7 );

this.unshift( true, {} );

// [ "true", "[object Object]", "1", "2", "3", "4", "5", "6", "7" ]
console.log( mkArray.toJSON() );</code></pre><h5><p>Условная Модель</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediateItem( function( item ) {
	if( item.something ) {
		return new FirstModel( item );
	} else {
		return new SecondModel( item );
	}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-mediateItem" data-title="Метод Matreshka.Array-mediateItem">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-on">
	<h2>
		<a href="#Matreshka.Array-on">
			<span class="memberof">Matreshka.Array#</span>on<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает так же, как и <a href="#Matreshka-on">Matreshka#on</a>, но дополнительно позволяет динамически навешивать обработчики на вставленные элементы.</p></div>
	<div class="description"></div>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( '@something', function() {
	alert( 'something happens' )
});

this.push( new MK );

this[0].trigger( 'something' );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-on" data-title="Метод Matreshka.Array-on">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-recreate">
	<h2>
		<a href="#Matreshka.Array-recreate">
			<span class="memberof">Matreshka.Array#</span>recreate<wbr>(<span class="args">array, eventOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Пересоздает экземпляр <a href="#Matreshka.Array">Matreshka.Array</a></p></div>
	<div class="description"><p>Метод позволяет конвертировать любой массив (или объект, подобный массиву) в экземпляр <a href="#Matreshka.Array">Matreshka.Array</a>. Если ничего не передано в качестве первого аргумента, экземпляр очищается.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">recreate</span> <span class="event">modify</span> <span class="event">add</span> <span class="event">addone</span> <span class="event">remove</span> <span class="event">removeone</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						array
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> <p>Массив</p></td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// очищаем массив и добавляем 5 новых элементов
this.recreate( [1, 2, 3, 4, 5] );

// очищаем массив
this.recreate();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-recreate" data-title="Метод Matreshka.Array-recreate">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-toArray">
	<h2>
		<a href="#Matreshka.Array-toArray">
			<span class="memberof">Matreshka.Array#</span>toArray<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует <a href="#Matreshka.Array">Matreshka.Array</a> в обычный массив, но не конвертирует входящие в него элемены</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.toArray();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toArray" data-title="Метод Matreshka.Array-toArray">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-toNative">
	<h2>
		<a href="#Matreshka.Array-toNative">
			<span class="memberof">Matreshka.Array#</span>toNative<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#Matreshka.Array-toArray">Matreshka.Array#toArray</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.toNative();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toNative" data-title="Метод Matreshka.Array-toNative">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method new" id="Matreshka.Array-rerender">
	<h2>
		<a href="#Matreshka.Array-rerender">
			<span class="memberof">Matreshka.Array#</span>rerender<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Перерисовывает DOM узлы элементов, входящих в массив</p></div>
	<div class="description"><p>Этот метод, как правило, используется тогда, когда свойство <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> устанавливается после того, как элементы были добавлены в массив.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = new MK.Array;

// DOM не меняется, так как itemRenderer еще не определен
mkArray.push( ... );

// определяем itemRenderer
mkArray.itemRenderer = function() { '&lt;div>MyDiv&lt;/div>' };

// DOM перерисовывается
mkArray.rerender();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-rerender" data-title="Метод Matreshka.Array-rerender">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-hasOwnProperty">
	<h2>
		<a href="#Matreshka.Array-hasOwnProperty">
			<span class="memberof">Matreshka.Array#</span>hasOwnProperty<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="boolean">boolean</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Существует ли свойство в экземпляре (индекс или свойство <code>length</code>)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="boolean">boolean</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = new MK.Array( 42 ); // создает массив длиной 42

mkArray.hasOwnProperty( 5 ); // true

mkArray.hasOwnProperty( 100500 ); // false

mkArray.hasOwnProperty( 'length' ); // true

mkArray.hasOwnProperty( 'blah' ); // false</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-hasOwnProperty" data-title="Метод Matreshka.Array-hasOwnProperty">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-toJSON">
	<h2>
		<a href="#Matreshka.Array-toJSON">
			<span class="memberof">Matreshka.Array#</span>toJSON<wbr>(<span class="args"></span>)
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр и элементы, входящие в него в обычный массив</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var data = this.toJSON();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toJSON" data-title="Метод Matreshka.Array-toJSON">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-pull">
	<h2>
		<a href="#Matreshka.Array-pull">
			<span class="memberof">Matreshka.Array#</span>pull<wbr>(<span class="args">index, evtOptions</span>)
		</a> <span class="returns">→ 
	<span data-type="*">*</span>

	<span data-type="null">null</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет элемент с заданным индексом из массива и возвращает этот элемент. Начиная с версии 0.3, метод поддерживает удаляемый элемент в качестве аргумента.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="*">*</span>

	<span data-type="null">null</span>

		 - Удаленный элемент или null

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">pull</span> <span class="event">remove</span> <span class="event">removeone</span> <span class="event">modify</span>

	</p>
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						index
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="number">number</span>

	<span data-type="*">*</span>
</td>
					<td> <p>Индекс элемента, который нужно удалить (число или строка) либо сам удаляемый элемент (не являющийся ни числом ни строкой)</p></td>
				</tr>
			 
				<tr>
					<td>
						evtOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> <p>Объект события на случай, если нужно передать в обработчик события какие-нибудь данные или установить флаг <code>silent</code>, предотвращающий срабатывание события</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Передача индекса массива</p></h5>
<pre class="prettyprint source lang-js"><code>var removed;

this.recreate( [ 'a', 'b', 'c' ] );

removed = this.pull( 1 );

alert( removed ); // 'b'

alert( this.toString() ); // 'a,c'</code></pre><h5><p>Передача удаляемого элемента</p></h5>
<pre class="prettyprint source lang-js"><code>var object1 = {},
	object2 = {},
	object3 = {},
	removed;

this.push( object1, object2, object3 );

removed = this.pull( object2 );

alert( removed === object2 ); // true

alert( this.length ); // 2</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-pull" data-title="Метод Matreshka.Array-pull">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-each">
	<h2>
		<a href="#Matreshka.Array-each">
			<span class="memberof">Matreshka.Array#</span>each<wbr>(<span class="args">callback, thisArg</span>)
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает точно так же, как и метод <code>forEach</code>, который перебирает элементы массива</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> <p>Функция, запускаемая на каждой итерации</p></td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>Объект, который используется в качестве <code>this</code> при вызове <code>callback</code></p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.each( function( item, index ) {
	console.log( index, item ); 
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-each" data-title="Метод Matreshka.Array-each">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-METHOD">
	<h2>
		<a href="#Matreshka.Array-METHOD">
			<span class="memberof">Matreshka.Array#</span>METHOD<wbr>(<span class="args"></span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Любой метод из <code>Array.prototype</code></p></div>
	<div class="description"><p><a href="#Matreshka.Array">Matreshka.Array</a> включает в себя все методы, входящие в нативный JavaScript массив:</p>
<p><ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concat</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank">join</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank">reverse</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString"  target="_blank">toString</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank">every</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank">lastIndexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank">some</a></li>
</ul>
При этом, они работают точно так же, как и методы <code>Array.prototype</code>. Есть лишь несколько оговорок:</p>
<ul>
<li>Метод <code>forEach</code> возвращает себя вместо <code>undefined</code></li>
<li>Методы, которые в оригинальном виде возвращают новый массив (<code>splice</code>, <code>slice</code>, <code>filter</code>, <code>map</code>...), в Матрешке возвращают новый экземпляр <code>Matreshka.Array</code>.</li>
</ul>
<p>Кроме всего, методы генерируют события связанные с любой модификацией массива. Подробнее см. <a href="#Matreshka.Array">Matreshka.Array</a>.</p></div>
	
	
	
	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-_METHOD">Matreshka.Array#_METHOD</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.push( 1, 2, 3 );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var mapped = this
	.forEach( function( value, index ) {
		//...
	})
	.map( function( value, index ) {
		//...
	})
;
alert( mapped.isMKArray );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.reverse();</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-METHOD" data-title="Метод Matreshka.Array-METHOD">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

<article class="item method " id="Matreshka.Array-METHOD_">
	<h2>
		<a href="#Matreshka.Array-METHOD_">
			<span class="memberof">Matreshka.Array#</span>METHOD_<wbr>(<span class="args"></span>)
		</a> 
		<i class="important" title="Важно"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Любой метод из <code>Array.prototype</code> с возможностью передать объект события</p></div>
	<div class="description"><p>Ознакомившись с <a href="#Matreshka.Array-METHOD">Matreshka.Array#METHOD</a> становится понятно, что методы не поддерживают передачу объекта события, так как в точности повторяют синтаксис и количество аргументов встроенного <code>Array</code>. Синтаксис <code>МЕТОД_</code> позволяет передать в обработчик события какие-нибудь данные либо установить служебные флаги, отвечающие за поведение массива после вызова метода.</p>
<p>Список доступных флагов:</p>
<ul>
<li><code>silent: true</code> - отключает генерацию событий</li>
<li><code>dontRender: true</code> - отключает <a href="#Matreshka.Array-itemRenderer">рендеринг</a></li>
<li><code>skipMediator: true</code> - отключает <a href="#Matreshka.Array-mediateItem">медиаторы</a></li>
</ul></div>
	
	
	
	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#Matreshka.Array-METHOD">Matreshka.Array#METHOD</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.push_( 1, 2, 3, {
    silent: true
});

this.pop_({
    silent: true
});</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.on( 'modify', function( evt ) {
	alert( evt.flag ); // 42
});

this.push_( 1, 2, 3, {
	flag: 42
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-METHOD_" data-title="Метод Matreshka.Array-METHOD_">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 

	
	
	
</section>


<section>

	
<article class="item method " id="Class">
	<h2>
		<a href="#Class">
			Class<wbr>(<span class="args">prototype</span>)
		</a> <span class="returns">→ 
	<span data-type="class">class</span>
</span>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Реализация классов, основанная на прототипном наследовании</p></div>
	<div class="description"><p>Функция <code>Class</code> позволяет использовать классическое ООП, основанное на классах. Для современных браузеров классы базируются на прототипном наследовании, а в Internet Explorer 8 используется хак, котрый разрешает использовать акцессоры (геттеры и сеттеры), с помощью функции Object.defineProperty.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="class">class</span>

		 - class (точнее, конструктор класса)

	</p>
	
	
	
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						prototype
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> <p>Методы и свойства</p></td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var A = Class({
	method1: function() { ... }
});

var B = Class({
	// B наследуется от A
	'extends': A,
	method2: function() { ... }
});

var C = Class({
	// С наследуется от B
	'extends': B,
	method2: function() {
		// вызов родительского метода
		B.prototype.method2.apply( this, arguments );
	},
	method3: function( a, b ) { ... }
});

var D = Class({
	// D наследуется от C
	'extends': C,
	method3: function( a, b ) {
		// вызов родительского метода
		C.prototype.method2.call( this, arguments );
	}
});</code></pre><h5><p>Использование AMD (именованные модули)</p></h5>
<pre class="prettyprint source lang-js"><code>retuire.config({
	paths: {
		'xclass': 'path/to/matreshka.min',
		'matreshka': 'path/to/matreshka.min',
		'balalaika': 'path/to/matreshka.min'
	}
});
require(['xclass', 'matreshka', 'balalaika'], function(Class, MK, $) {
	var MyClass = Class({
		'extends': MK,
		constructor: function() {
			// ...
		}
	});
});</code></pre><h5><p>Использование AMD (безымянный модуль)</p></h5>
<pre class="prettyprint source lang-js"><code>// Матрешка содержит функции Class и $b, как статичные свойства
require(['path/to/matreshka.min'], function(MK) {
	var MyClass = MK.Class({
		'extends': MK,
		constructor: function() {
			// ...
		}
	});
});</code></pre><h5><p>Использование функции <code>Class</code> обязательно для IE8, но не трубуется в других браузерах. Поэтому, Матрешка из коробки поддерживает любой вид прототипного наследования, в том числе и синтаксис ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class A extends B {
	constructor() {
		super();
		this.sayHello();
	}

	sayHello() {
		alert("Hello World!");
	}
}</code></pre><h5><p><strong>Метод <code>instanceOf</code></strong>. Экземпляры класса, созданного при помощи функции <code>Class</code> включают в себя метод <code>instanceOf</code>, проверяющий, является ли объект экземпляром заданного класса. Этот метод нужен только тогда, когда ваше приложение требует поддержки IE8</p></h5>
<pre class="prettyprint source lang-js"><code>// для IE8 и остальных браузеров
alert( this.instanceOf( MyClass ) );

// для нормальных браузеров
alert( this instanceof MyClass );</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Class" data-title="Метод Class">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 


	
<article class="item method " id="$b">
	<h2>
		<a href="#$b">
			$b<wbr>(<span class="args"></span>)
		</a> 
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Микро-библиотека Балалайка</p></div>
	<div class="description"><p>Балалайка - это крошечная (на момент написания этой статьи 605 байт) jQuery-подобная библиотека для работы с DOM . Она наследуется от <code>Array.prototype</code> и включает в себя все методы, которые есть у массива:</p>
<ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concat</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank">join</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank">reverse</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString"  target="_blank">toString</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank">every</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank">lastIndexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank">some</a></li>
</ul>

<p>Кроме этого, она включает несколько событвенных методов: <code>on</code>, <code>off</code>, <code>is</code>, <code>extend</code>, возможности парсинга HTML, отлов события DOM-ready и пр. Балалайка используется внутренними механизмами Матрешки тогда, когда на странице не подключена jQuery или другая jQuery-подобная библиотека.</p></div>
	
	
	
	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://github.com/finom/balalaika">Балалайка на Github</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>Создание обработчика события</p></h5>
<pre class="prettyprint source lang-js"><code>$('.my-selector').on('click.namespace', function() {
   alert('I need my balalaika');
});</code></pre><h5><p>Удаление обработчика</p></h5>
<pre class="prettyprint source lang-js"><code>$('.my-selector').off('click.namespace');</code></pre><h5><p>Метод <code>is</code></p></h5>
<pre class="prettyprint source lang-js"><code>$('.my-selector').on('click', function(evt) {
   if($(evt.target).is('.another-selector')) {
       alert('I need my balalaika');
   }
});</code></pre><h5><p>Метод <code>extend</code> (расширение одного объекта другим)</p></h5>
<pre class="prettyprint source lang-js"><code>var myObject = {a:1};
$.extend(myObject,{
   b: 2
});</code></pre><h5><p>DOM-ready</p></h5>
<pre class="prettyprint source lang-js"><code>$(function() {
   // Do something with DOM
});</code></pre><h5><p>Парсинг</p></h5>
<pre class="prettyprint source lang-js"><code>var elements = $('&lt;div>&lt;span class="yeah">&lt;/span>&lt;/div>');</code></pre><h5><p>Поиск одного элемента в другом</p></h5>
<pre class="prettyprint source lang-js"><code>var myElement = $('.my-selector', node);</code></pre><h5><p>Установка стиля</p></h5>
<pre class="prettyprint source lang-js"><code>$('.my-selector').forEach(function(el) {
   $.extend( el.style, {
       width: '30px',
       backgroundColor: 'red'
   });
});</code></pre><h5><p>Делегирование события</p></h5>
<pre class="prettyprint source lang-js"><code>$('.my-selector').on('click', function(evt) {
   var node = evt.target;
   while(node !== this) {
       if($(node).is('.delegated-selector')) {
           // Handle it!
           break;
       }
       node = node.parentNode;
   }
});</code></pre><h5><p>Простой плагин</p></h5>
<pre class="prettyprint source lang-js"><code>$.fn.addClass = function( className ) {
   this.forEach( function( item ) {
       var classList = item.classList;
       classList.add.apply( classList, className.split( /\s/ ) );
   });
   return this;
};</code></pre><h5><p>Функция <code>create</code> - дополнительная утилита для создания элементов, входящая в комплект Матрешки. Первый аргумент - имя тега, второй - свойства, расширяющие DOM объект</p></h5>
<pre class="prettyprint source lang-js"><code>var div = $.create( 'div', {
	className: 'my-div',
	innerHTML: 'My DIV'
	dataset: {
		a: 1,
		b: 2
	}
});</code></pre>
	
	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="$b" data-title="Метод $b">Задать вопрос<i></i></a>
<div class="comments-container"></div>
</article> 
 


</section>
<section>

	
<article class="item typedef" data-typedef="eventHandler">
	<i class="close-modal"></i>
	<h2>
		eventHandler:
			<span data-type="function">function</span>
		
	</h2>
	
	<p>Функция-обработчик события. Принимает любые аргументы, переданные в <a href="#Matreshka-trigger">Matreshka#trigger</a></p>
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						options
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> <p>любые аргументы, переданные в вызов <a href="#Matreshka-trigger">Matreshka#trigger</a> после имени собыия</p></td>
				</tr>
			
		</tbody>
	</table>

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var eventHandler = function() {
	console.log( arguments ); 
}
this.on( 'fyeah', eventHandler );
this.trigger( 'fyeah', 'foo', 'bar', 'baz' ); // logs 'foo', 'bar', 'baz'</code></pre>
</article>


	
<article class="item typedef" data-typedef="matreshka">
	<i class="close-modal"></i>
	<h2>
		matreshka:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#Matreshka">Matreshka</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="matreshkaObject">
	<i class="close-modal"></i>
	<h2>
		matreshkaObject:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#Matreshka.Object">Matreshka.Object</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="matreshkaArray">
	<i class="close-modal"></i>
	<h2>
		matreshkaArray:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#Matreshka.Array">Matreshka.Array</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="balalaika">
	<i class="close-modal"></i>
	<h2>
		balalaika:
			<span data-type="array">array</span>
		
	</h2>
	
	<p>Коллекция <a href="#$b">балалайки</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="eventNames">
	<i class="close-modal"></i>
	<h2>
		eventNames:
			<span data-type="string">string</span>
		
	</h2>
	
	<p>Имя события или несколько имен, разделенных пробелами.</p>
<p>Существует несколько видов событий:</p>
<ul>
<li>Произвольные события</li>
<li><code>change:KEY</code></li>
<li><code>DOM_EVENT::KEY</code></li>
<li><code>DOM_EVENT::KEY(.DELEGATED-SELECTOR)</code></li>
<li><code>DOM_EVENT::(.DELEGATED-SELECTOR-FROM-SANDBOX)</code></li>
<li><code>KEY@EVENT_NAME</code></li>
<li><code>@EVENT_NAME</code> (для <a href="#Matreshka.Object">Matreshka.Object</a> и <a href="#Matreshka.Array">Matreshka.Array</a>)</li>
</ul>
<h3>Произвольное событие</h3><p>Такое событие может быть сгенерировано программистом вручную с помощью метода <a href="#Matreshka-trigger">Matreshka#trigger</a></p>
<pre class="prettyprint source lang-js"><code>this.on( 'x y z', function( message ) {
    alert( message );
});

this.trigger( 'y', '"y" event is fired' );</code></pre><h3>Событие изменения свойства</h3><pre class="prettyprint source lang-js"><code>this.on( 'change:x', function( evt ) {
    alert( evt.value );
});
this.x = 1;</code></pre><h3>DOM события для привязанных элементов</h3><p>DOM событие и ключ разделяются двойным двоеточием. Объект оригинального DOM события находится под ключём <code>domEvent</code> объекта события. Кроме этого, в объекте доступно несколько свойств и методов, для того чтобы не обращаться каждый раз к <code>domEvent</code>: <code>preventDefault</code>, <code>stopPropagation</code>, <code>which</code>, <code>target</code> и несколько других свойств (<code>key</code>, <code>element</code>, <code>elements</code>, <code>self</code>).</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'x', '.my-button' );
this.on( 'click::x', function( evt ) {
    alert( 'clicked "x"' );
    console.log( evt.domEvent ); // MouseEvent
});</code></pre><h3>Делегированные DOM события для привязанных элементов</h3><p>Такой синтаксис позволяет навесить обработчик события на дочерний элемент внутри привязанного элемента, даже если дочерний элемент еще не существует. Этот вариант используется тогда, когда программист не хочет создавать еще одну дополнительную привязку для того, чтоб добавить небольшой DOM обработчик.
Селектор указывается в скобках после ключа. Оригинальное DOM событие находится под ключём <code>domEvent</code> объекта события.</p>
<pre class="prettyprint source lang-html"><code>&lt;div class="my-div">
    &lt;button class="my-button">&lt;/button>
&lt;/div></code></pre><p>Сравните два варианта:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'x', '.my-div' );
this.bindNode( 'y', '.my-button' );
this.on( 'click::y', function( evt ) {
    alert( 'clicked ".my-button"' );
});</code></pre><pre class="prettyprint source lang-js"><code>this.bindNode( 'x', '.my-div' );
this.on( 'click::x(.my-button)', function( evt ) {
    alert( 'clicked ".my-button"' );
});</code></pre><p>В первом случае приходится привязать кнопку прежде чем навешать обработчик, заставляя придумывать имя для ключа, который, в дальнейшем не используется.</p>
<h3>Делегированные DOM события для песочницы</h3><p>Как известно из документации к <a href="#Matreshka-bindNode">Matreshka#bindNode</a>, для того, чтоб объявить песочницу нужно всего-навсего связать специальный ключ <code>sandbox</code> с соответствующим элементом. Напоминаем, песочница нужна для того, чтоб привязки внутри экземпляра класса были ограничены одним элементом, не влезая на территорию другого экземпляра и не создавая конфликтов селекторов.</p>
<p>Синтаксис делегированных событий описан выше:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.my-div' );
this.on( 'click::sandbox(.my-button)', function( evt ) {
    alert( 'clicked ".my-button"' );
});</code></pre><p>Но, есть более краткий способ записи такого события, без указания ключа <code>sandbox</code></p>
<pre class="prettyprint source lang-js"><code>this.bindNode( 'sandbox', '.my-div' );
this.on( 'click::(.my-button)', function( evt ) {
    alert( 'clicked ".my-button"' );
});</code></pre><p>Оригинальное DOM событие находится под ключём <code>domEvent</code> объекта события.</p>
<h3>Делегированные события Матрешки</h3><p>Для того, чтоб отловить событие внутри свойства, если значением этого свойства является другой экземпляр Матрешки, можно использовать специальный синтаксис <code>КЛЮЧ@ИМЯ_СОБЫТИЯ</code>. Таким образом, программисту не требуется всё время следить за значением свойства</p>
<p>Сравните два подхода. Первый - простой: слушаем изменения свойства, проверяем, является ли значение свойства экземпляром Матрешки, невешиваем обработчик.</p>
<pre class="prettyprint source lang-js"><code>this.on( 'change:x', function() {
    if( this.x && this.x.isMK ) {
        this.x.on( 'y', function( message ) {
            alert( message );
        });
    }
});
this.x = new Matreshka;
this.x.trigger( 'y', '"y" event is fired' );</code></pre><p>Вариант с использованием делегированных событий Матрешки выглядит многократно элегантнее.</p>
<pre class="prettyprint source lang-js"><code>this.on( 'x@y', function( message ) {
    alert( message );
});
this.x = new Matreshka;
this.x.trigger( 'y', '"y" event is fired' );</code></pre><h3>Делегированные события <a href="#Matreshka.Object">Matreshka.Object</a> и <a href="#Matreshka.Array">Matreshka.Array</a></h3><p>В предыдущем варианте делегированных событий мы заранее знаем ключ свойства. Так как <a href="#Matreshka.Object">Matreshka.Object</a> и <a href="#Matreshka.Array">Matreshka.Array</a> ведут себя как коллекции (у <a href="#Matreshka.Object">Matreshka.Object</a> есть метод <a href="#Matreshka.Object-each">Matreshka.Object#each</a> для перебора всех ключей, отвечающих за данные), мы заранее можем не знать под какими ключами или индексами будут содержаться нужные нам экземпляры. Для того, чтоб навесить обработчик неизвестное свойство, в эти классы был добавлен дополнительный синтаксический сахар: <code>@ИМЯ_СОБЫТИЯ</code>.</p>
<p>Пример с <a href="#Matreshka.Object">Matreshka.Object</a>.</p>
<pre class="prettyprint source lang-js"><code>this.on( '@y', function( message ) {
    alert( message );
});
this.jset('x', new Matreshka );
this.x.trigger( 'y', '"y" event is fired' );</code></pre><p>Пример с <a href="#Matreshka.Array">Matreshka.Array</a>.</p>
<pre class="prettyprint source lang-js"><code>this.on( '@y', function( message ) {
    alert( message );
});
this.push( new Matreshka );
this[0].trigger( 'y', '"y" event is fired' );</code></pre><h3>Всевозможные комбинации</h3><p>Все приведенные выше варианты синтаксиса можно комбинировать произвольным способом.</p>
<pre class="prettyprint source lang-js"><code>this.on( '@click::x z@y', function() { ... } );</code></pre><pre class="prettyprint source lang-js"><code>this.on( 'property@click::(.my-selector)', function() { ... } );</code></pre><pre class="prettyprint source lang-js"><code>this.on( 'x@y@z', function() { ... } );</code></pre>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="binder">
	<i class="close-modal"></i>
	<h2>
		binder:
			<span data-type="object">object</span>
		
	</h2>
	
	<p><code>binder</code> (байндер, привязчик) содержит всю информацию о том, как синхронизировать значение свойства с привязанным к нему DOM элементом. Для всех методов байндера контекст (<code>this</code>) - соответствующий DOM узел.</p>
	
	
	<h4>Свойства</h4>
	<table class="properties">
		<thead>
			<tr>
				<th>Имя
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						on
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="string">string</span>

	<span data-type="function">function</span>

					<td><p>DOM событие (или список событий, разделенных пробелами), после срабатывания которого извлекается состояние DOM элемента и устанавливается свойство. Кроме этого, значением свойства может быть функция, которая устанавливает обработчик произвольным образом.</p>
				</tr>
			 
				<tr>
					<td>
						getValue
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td><p>Функция, которая отвечает за то, как извлечь значение (или &quot;состояние&quot;) DOM элемента</p>
				</tr>
			 
				<tr>
					<td>
						setValue
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td><p>Функция, которая отвечает за то, как установить значение свойства DOM элементу</p>
				</tr>
			 
				<tr>
					<td>
						initialize
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td><p>Функция, которая запускается при инициализации привязки. Например, может быть использована для инициализации jQuery плагина.</p>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var binder = {
	on: 'click',
	getValue: function( options ) {
		return this.value;
	} 
	setValue: function( v, options ) {
		this.value = v;
	},
	initialize: function( options ) {
		alert( 'Binder is initialized. Initial input value=' + this.value );
	}
};

this.bindNode( 'a', '.my-checkbox', binder );</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var binder = {
	on: function( callback ) {
		this.onclick = callback;
	},
	getValue: function( options ) {
		return this.value;
	} 
	setValue: function( v, options ) {
		this.value = v;
	},
	initialize: function( options ) {
		alert( 'Binder is initialized. Initial input value=' + this.value );
	}
};

this.bindNode( 'a', '.my-checkbox', binder );</code></pre>
</article>


	
<article class="item typedef" data-typedef="eventOptions">
	<i class="close-modal"></i>
	<h2>
		eventOptions:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Это обычный объект, которй может содержать служебные флаги или произвольные данные, которые попадут в обработчик события</p>
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var eventOptions = { silent: true };

this.a = 1;

this.on( 'change:a', function() {
	alert( 'a is changed' );
});

this.set( 'a', 2, eventOptions ); // no alert</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var eventOptions = { f: 'yeah' };

this.a = 1;

this.on( 'change:a', function( eventOptions ) {
	alert( eventOptions.f );
});

this.set( 'a', 2, eventOptions ); // alerts "yeah"</code></pre>
</article>


	
<article class="item typedef" data-typedef="class">
	<i class="close-modal"></i>
	<h2>
		class:
			<span data-type="function">function</span>
		
	</h2>
	
	<p>Класс (точнее, конструктор класса) возвращаемый функцией <a href="#Class">Class</a></p>
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	method: function() { ... }
});</code></pre>
</article>


	
<article class="item typedef" data-typedef="node">
	<i class="close-modal"></i>
	<h2>
		node
	</h2>
	
	<p>DOM узел</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="$nodes">
	<i class="close-modal"></i>
	<h2>
		$nodes
	</h2>
	
	<p>Коллекция DOM узлов. Например, jQuery-элемент(ы)</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="string">
	<i class="close-modal"></i>
	<h2>
		string
	</h2>
	
	<p>Строка</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="boolean">
	<i class="close-modal"></i>
	<h2>
		boolean
	</h2>
	
	<p>Логический тип</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="number">
	<i class="close-modal"></i>
	<h2>
		number
	</h2>
	
	<p>Число</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="object">
	<i class="close-modal"></i>
	<h2>
		object
	</h2>
	
	<p>Объект</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="array">
	<i class="close-modal"></i>
	<h2>
		array
	</h2>
	
	<p>Массив</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="function">
	<i class="close-modal"></i>
	<h2>
		function
	</h2>
	
	<p>Функция</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="null">
	<i class="close-modal"></i>
	<h2>
		null
	</h2>
	
	<p>null</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="*">
	<i class="close-modal"></i>
	<h2>
		*
	</h2>
	
	<p>Любой тип</p>
	
	
	

	  

</article>


</section>
<section>
<article id="whats-new"><h2><a href="#whats-new">Что нового?</a></h2><h3>Матрешка 1.0</h3><ul>
<li>Убраны предупреждения об использовании устаревших методов и событий, очищен код.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v0.3.0">Матрешка 0.3</a></h3><p><strong>Новые возможности</strong></p>
<ul>
<li>Метод <a href="#Matreshka.randomString">Matreshka.randomString</a></li>
<li>Метод <a href="#Matreshka-onDebounce">Matreshka#onDebounce</a></li>
<li>Метод <a href="#Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a></li>
<li>Метод <a href="#Matreshka-delay">Matreshka#delay</a></li>
<li>Методы <code>Matreshka.Array</code>, позволяющие передать объект события (<code>push_</code>, <code>sort_</code>, <code>splice_</code>...). См. <a href="#Matreshka.Array-METHOD_">Matreshka.Array#METHOD_</a></li>
<li>Свойство <a href="#Matreshka.version">Matreshka.version</a></li>
<li>Новый односторонний байндер <a href="#Matreshka.binders.visibility">Matreshka.binders.visibility</a></li>
<li>Свойство <code>on</code> у привязчика может быть функцией</li>
<li>Добавлен флаг <code>skipMediator</code> для методов <code>Matreshka.Array</code></li>
<li>Переопределение <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> свойством <code>renderer</code> дочернего элемента</li>
<li>Свойство <a href="#Matreshka.Array-renderIfPossible">Matreshka.Array#renderIfPossible</a></li>
<li>Функция <a href="#Matreshka.lookForBinder">Matreshka.lookForBinder</a> теперь статичный метод класса <a href="#Matreshka">Matreshka</a></li>
<li>Для привязки песочницы теперь используется ключ <code>sandbox</code> вместо <code>__this__</code></li>
<li>События <code>addone</code> и <code>removeone</code> для <a href="#Matreshka.Array">Matreshka.Array</a></li>
<li><a href="#Matreshka.Array-push">Matreshka.Array#push</a> и <a href="#Matreshka.Array-unshift">Matreshka.Array#unshift</a> теперь возвращают длину массива вместо себя (как и в нативном массиве)</li>
<li>Реализованы привязчики для всех HTML5 элементов формы</li>
<li>Новые служебные флаги для метода  <a href="#Matreshka-set">Matreshka#set</a>: <code>silentHTML</code>, <code>skipLinks</code></li>
<li><a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> теперь поддерживает строку, как значение</li>
<li>Добавлен ключ <code>self</code> для всех событий <code>Matreshka.Array</code></li>
<li>Можно менять <a href="#Matreshka.Array-Model">Matreshka.Array#Model</a> динамически</li>
<li>Вызывать событие <code>change</code>, если при привязке Матрешка меняет значение свойства на состояние элемента (если свойство не определено и не передан флаг <code>assignDefaultValue: false</code>)</li>
<li>Новые селекторы: <code>:sandbox</code> и <code>:bound(KEY)</code></li>
<li>Поддержка свойства <code>attributes</code> для функции <code>Balalaika.create</code></li>
<li>Экспериментальный шаблонизатор для <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> если <a href="#Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> установлен, как <code>true</code></li>
<li>Перенесены все привязчики в объект <a href="#Matreshka.binders">Matreshka.binders</a></li>
<li><a href="#Matreshka.Array-pull">Matreshka.Array#pull</a> теперь поддерживает объект в качестве аргумента</li>
<li>Короткая запись для делегированных событий DOM внутри песоницы (click::(.selector) вместо click::sandbox(.selector))</li>
<li>Поддержка цикла <code>for..of</code> для {@link Matreshka.ArrayЪ и {@link Matreshka.ObjectЪ</li>
<li>Свойство <code>domEvent</code> содержащее объект события для событий DOM</li>
<li>Делегированные DOM события (<code>this.on( 'click::something(.x &gt; .y)' )</code>)</li>
</ul>
<p><strong>Устаревшие методы и события</strong></p>
<ul>
<li>Все методы, имя которых начинается с <code>silent</code> (<code>silentPush</code>, <code>silentSplice</code>, <code>silentSort</code> ...) удалены. Для этих целей теперь используются методы с нижним подчеркиванием в конце имени и флагом <code>silent</code> (например, <code>this.push_(1,2,3, {silent: true})</code>)</li>
<li>Метод <code>Matreshka#initMK</code> удален, теперь используется ленивая инициализация</li>
<li>Метод <code>Matreshka#defineNotEnum</code> удален по причине неиспользуемости</li>
<li>Matreshka.Array#initializeSmartArray -&gt; <a href="#Matreshka.Array-rerender">Matreshka.Array#rerender</a></li>
<li>Matreshka#setMediator -&gt; <a href="#Matreshka-mediate">Matreshka#mediate</a></li>
<li>Matreshka#bindElement -&gt; <a href="#Matreshka-bindNode">Matreshka#bindNode</a></li>
<li>Matreshka#unbindElement -&gt; <a href="#Matreshka-unbindNode">Matreshka#unbindNode</a></li>
<li>Matreshka#addDependency -&gt; <a href="#Matreshka-linkProps">Matreshka#linkProps</a></li>
<li>Matreshka.Array#setItemMediator -&gt; <a href="#Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a></li>
<li>Matreshka.Object#addJSONKeys -&gt; <a href="#Matreshka.Object-addDataKeys">Matreshka.Object#addDataKeys</a></li>
<li>Matreshka.Object#removeJSONKeys -&gt; <a href="#Matreshka.Object-removeDataKeys">Matreshka.Object#removeDataKeys</a></li>
<li>Matreshka.procrastinate -&gt; <a href="#Matreshka.debounce">Matreshka.debounce</a></li>
<li>Удалено событие <code>itemrender</code> из Matreshka.Array. Можно использовать <code>@render</code> вместо него</li>
</ul>
<p><strong>Исправленные баги</strong></p>
<ul>
<li>Фиксы в <a href="#$b">Балалайке</a> для старых браузеров WebKit, например, iOS 5 Safari</li>
<li>Обработчик DOM события вызывался несколько раз</li>
<li><a href="#Matreshka-off">Matreshka#off</a> теперь возвращает себя</li>
<li>Исправлен баг в <a href="#Matreshka-defineGetter">Matreshka#defineGetter</a></li>
<li>Исправлен баг в <a href="#Matreshka.Array-concat">Matreshka.Array#concat</a></li>
<li>Исправлен баг в <a href="#Matreshka-once">Matreshka#once</a></li>
<li>Исправлен баг в <a href="#Matreshka.Array-itemMediator">Matreshka.Array#itemMediator</a></li>
<li>Исправлен баг в механизме рендеринга <a href="#Matreshka.Array">Matreshka.Array</a></li>
<li>Небольшие исправления в <a href="#Matreshka-bindNode">Matreshka#bindNode</a></li>
<li>Небольшие исправления для стандартных байндеров</li>
<li>Делегированные события не работали для <a href="#Matreshka.Object">Matreshka.Object</a></li>
<li>Всегда возвращать <code>null</code> из <a href="#Matreshka-bound">Matreshka#bound</a> если элемент не найден</li>
<li>Исправлен неоевидный баг в <a href="#Matreshka-set">Matreshka#set</a>, возникающий при использовании <a href="#Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a> и <a href="#Matreshka.Array-linkProps">Matreshka.Array#linkProps</a> вместе</li>
<li>Использовать событие <code>delete</code> вместо <code>remove</code></li>
<li><code>binder.setValue</code> вызывался даже если значение свойства не было изменено</li>
<li>Привязанные HTML элементы не обновлялись поесле вызова <a href="#Matreshka-mediate">Matreshka#mediate</a></li>
<li>Фиксы для Internet Explorer 8</li>
<li>Matreshka.lookForBinder теперь возвращает <code>undefined</code> если байндер не найден</li>
<li>Генерировать события модификации Matreshka.Array <strong>только тогда</strong> коллекция изменилась</li>
</ul>
<p><strong>Изменения в коде</strong></p>
<ul>
<li>Оптимизирована генерация событий</li>
<li>Созданы методы _on и _off для внутреннего использования и улучшения производительности</li>
<li>Создан приватный метод Matreshka#_initMK</li>
<li>Оптимизирован код <a href="#Matreshka.Object">Matreshka.Object</a></li>
<li>Убран полифил Number.isNaN</li>
</ul></article><article id="how-to-update"><h2><a href="#how-to-update">Переход на новую версию</a></h2><p>Переход на версию 1.0 с любой предыдущей версии должен произойти относительно безболезненно, хотя и требует вмешательства в старый код.</p>
<ul>
<li>Сначала нужно обновиться до переходной версии 0.3, которая включает все исправления и нововведения, для первой версии.</li>
<li>После обновления вы увидете в консоли исключения с инструкциями, что нужно исправить, например убрать вызов устаревшего метода <code>initMK</code>. Пользуясь инструментами разработчика, отследите источники исключений с помощью stack trace. Так же, можете воспользоваться поиском по JavaScript файлам для отслеживания поиска устаревших методов.</li>
<li>Потестируйте своё приложение и, если исключения больше не возникают, обновитесь до верии 1.0.</li>
</ul></article>
</section>
</main>
<div class="typo-badge">
	<span class="close" title="Больше не показывать"></span>
	Нашли опечатку или ошибку? <br> Выберите текст и нажмите <br>
	<button>CTRL</button>+<button>Enter</button>
</div>
<form class="typo" method="POST" target="typo-iframe">
	<i class="close-modal"></i>
	<h5>Ошибка на сайте</h5>
	<p class="selection"></p>
	<textarea class="comment" rows="2" placeholder="Комментарий (не обязательно)"></textarea>
	<input type="hidden" class="page">
	<input type="hidden" class="selection">
	<div class="action-bar">
		<button type="submit">Отправить</button>
		<button class="cancel">Отменить</button>
	</div>
</form>
<script>
	window.disqus_shortname = 'matreshka-rus';
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12418613-5', 'auto');
  ga('send', 'pageview');

</script>
		<div class="hide nav-overlay"></div>
		<div class="hide typedef-overlay"></div>
		<div class="hide typo-overlay"></div>
		<script id="pagination-template" type="text/html">
			<div class="pagination">
				<a class="previous-page"></a>
				<a class="next-page"></a>
			</div>
		</script>
		<script src="js/dist/app.min.js"></script>
		<div id="fb-root"></div>
	</body>
</html>
